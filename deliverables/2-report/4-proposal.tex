\section{Generically sized arrays}

This section details a minimal design for the addition of generically sized
arrays and numerical type parameters to Go. We also compare this design against
the existing proposal by \autocite{goArrayProposal}, and discuss future
extensions to this feature.

\subsection{Type-set interfaces and the \kw{const} interface}

We've already looked at type set based interfaces introduced in Go 1.18. If we
treat array sizes as types, then we now have a conceptual set of types 0, 1, 2,
3, etc. Similarly, we can conceptually define the \kw{const} type as the type
set of all array sizes:

\golisting{./examples/reversed/const_type.go}

Where the \texttt{...} means the pattern repeats for all the non-negative
integers. In practice, \kw{const} would be another ``special'' predeclared
interface type, just like the existing \texttt{comparable} that ``denotes the
set of all non-interface types that are strictly comparable'' \autocite{spec}.
Just like \texttt{comparable}, \kw{const} would be an interface that can only be
used as a type parameter constraint, and not e.g. as the type of a variable,
function parameter or return type. This \texttt{comparable} interface is not
defined in terms of regular Go code, but rather exists on the level of the
language itself. \kw{const} would follow the same pattern. The choice of the
identifier \kw{const} is to ensure backwards compatibility with existing
programs, as this keyword is currently not allowed to be used as a type name.
Just like a union type set, \kw{const} can be instantiated with one of the
elements of the union, i.e. a non-negative integer literal. This restricts
numerical type arguments to strictly compile-time constant integers. Such a type
parameter could then be used as the size of an array. With such an extension, we
can express the \texttt{reversed} function from the previous section as follows:

\golisting{./examples/reversed/const_generic_type.go}

Note how once again, the body of the function remains unchanged. The only
difference is that \texttt{N} is now a type parameter bound by the
\texttt{const} interface. The above function can operate on any array of any
size and any element type.

The rest of this work looks at the theory and implementation of the \kw{const}
type into the existing Go language. We will examine a language called
Featherweight Generic Go With Arrays (FGGA), which is a subset of Go, modulo the
addition of numerical type parameters. Since FGGA only considers ``classic''
(method set) interfaces, \kw{const} will not be an interface type in FGGA, but
rather in its own category. This category can be though of as non-method set
interfaces, since the two have the same restrictions, i.e. they can only be used
as type parameter bounds.

\subsection{Comparison with existing proposal}

Shortly after the Type Parameters proposal was published
\autocite{genericsProposal}, a proposal to extend generics to array sizes was
published \autocite{goArrayProposal}. It would allow type set interfaces of the
following form:

\golisting{./examples/werner/array_interface.go}

In this design, the parameterisation of the array size in implicit using
\texttt{...}, and does not appear in the list of type parameters, meaning the
numerical type parameter cannot be referenced directly. Instead, the proposal
author suggests applying the feature as follows:

\golisting{./examples/werner/matrix.go}

The example can in fact be simplified slightly, by inlining the type set
directly in into the type parameter constraint (allowed as of Go 1.18):

\golisting{./examples/werner/matrix_inline.go}

It could then be instantiated as follows:

\golisting{./examples/werner/matrix_variable.go}

Compare this with the proposal presented in this work. Using the \kw{const}
interface, the analogous code would be as follows:

\golisting{./examples/werner/my_matrix.go}

This approach mandates much less boilerplate than the current proposal, as the
type consumer is not forced to create ``dummy'' type arguments, and the type
provider is not forced to retrieve an implicit numerical parameter through the
\texttt{len} function. Explicit numerical type parameters would make generic
arrays a first-class feature of Go, consistent with the rest of the language.
All the existing compound data types in Go can already be fully type
parameterised (slices: \texttt{[]T}, maps: \texttt{map[K]V} and channels:
\texttt{chan T}), except for arrays, so this work would bridge that gap
(\texttt{[N]T}), without making the feature feel like a workaround. In addition,
explicit numerical type parameters make the code more readable, as the
programmer can immediately see when a type is parameterised on integers.

Not only would arrays become first class, but so would numerical type
parameters. Currently, arrays are the only type which accept a numerical type
parameter, to parameterize the length of an array type. The \kw{const} interface
would allow any type or function to accept a constant integer (or another
\kw{const} bounded type parameter) as a type argument.

The benefit of Werner's proposal, is that is uses existing syntax:
\texttt{[...]T} can already be used to denote an array's type when constructing
an array literal:

\golisting{./examples/werner/array_literal.go}

where \texttt{myArray} has an inferred type of \texttt{[3]int}. It's worth
noting however, that this syntax is used for type inference, as opposed to
denote the type of a value, similar to how in some cases type arguments can be
omitted, where the compiler is able to infer what they are.

% TODO describe pros and cons of existing proposal
% cons: 
%       difficulty of implementing type arguments using expressions (e.g. len([...]T) + 1)

Another shortcoming of the implicit \texttt{[...]} syntax to parameterise array
sizes, is that it becomes unclear whether two type parameters of the same
constraint \texttt{[...]T} (as shown in figure \ref{fig:werner-ambiguity}) have
the same length. If yes, then how do we express two type parameters of the
different lengths? If no, then how do we express that two type parameters must
have the same length? How about when we use the shorthand syntax to collapse the
bounds of multiple type parameters? Explicit numerical type parameters make this
differentiation trivial, enhancing the readability of the code.

\begin{figure}
    \golisting{./examples/werner/array_pair.go}
    \golisting{./examples/werner/array_pair_collapsed.go}
    \caption{Examples of ambiguity when using \texttt{[...]T} to constrain
        multiple type parameters}
    \label{fig:werner-ambiguity}
\end{figure}

The proposal mentions making \texttt{len} applicable to array \emph{types} in
addition to array values (as seen in Werner's examples presented above),
however, as pointed out in the GitHub
issue\footnote{\url{https://github.com/golang/go/issues/44253\#issuecomment-820999513}},
this is uneccessary as the desired behaviour can already be achieved by applying
\texttt{len} to an instantiated value of an array type parameter.

\subsection{Allowed \texttt{const} type arguments}

We've already seen how constant non-negative integers can be used as numerical
type arguments. Additionally, since a numerical type parameter stands in for a
constant integer, it can itself be used as a type argument. This is consistent
with how in Go type parameters satisfy their own bounds, and is the basis for
creating nested generic structures. Arrays length parameters are generalized to
accept a \kw{const} type parameter, as seen in the matrix example, to fit into
this new definition.

How about an expression like \texttt{N + 1} or \texttt{2 * N}? Should we allow
them as \kw{const} type arguments? The question can be phrased as: is an
expression containing a \kw{const} type parameter and constant operations (i.e.
ones that can be computed at compile time, if we substitute the type parameter
for a concrete integer), a constant expression? Going forwards, when the answer
to the above questions is ``no'', it will be referred to as the conservative
approach, whereas a ``yes'' answer will be referred to as the liberal approach.

% TODO explain how conservative model prevents const variables from holding type
% parameters (due to transitivity), but allow type arguments

Constant expressions evaluate to constant integers, of which non-negative ones
can be used as \kw{const} type arguments. This brings us to our first problem,
not all constant expressions yield non-negative integers, and we cannot tell
what the sign of a ``constant'' expression involving a type parameter will be
until the use has instantiated a generic type or function. Go type checks
generic functions/types at the declaration site, rather than the call site, so
we need to ensure our approach fits that model.

Consider the signature of a function that returns the head and tail of an array
\autocite{rustConstBlog}:

\golisting{./examples/expressions/headtail.go}

Since an array length cannot be negative, it is only valid to pass arrays of
size 1 or more to this function. If the argument array's length was 0, then
\texttt{N - 1} would evaluate to \texttt{-1}, which is an invalid array size.
Conceptually, we can think of this constraint as a new interface, a
\emph{subtype} of \kw{const}:

\golisting{./examples/expressions/constplus1.go}

This leads us to at least three potential solutions to the above problem. The
first would be to fail the type checking of such a function (at declaration
site), since the operation is not valid on for all instantiations of the
\kw{const} interface. Just as underflow can occur when performing operations
that can decrease the value of a numerical type parameter, overflow could occur
if the instantiated type argument is large enough and a constant expression
makes it overflow (i.e. fail to fit into an \texttt{int} type, whose size is
platform dependant). The is where the first potential solution falls short,
since overflow could occur with expressions such as \texttt{N + 1} or \texttt{2
    * N}, those expressions would also not be allowed by same the argument of not
being valid for all instantiations, and in effect we're back to the conservative
approach.

The other 2 solutions revolve around constraining the type parameter bound more
tightly (as shown in the \texttt{constPlus1} interface code). This could be done
implicitly: the compiler could detect that the operation is only permitted for
numerical type parameter instantiations greater than 0, and implicitly make the
type parameter constraint bounds tighter. I.e. the function still type checks at
the declaration site, however callers would only be able to pass in non-zero
sized arrays, which can be checked at compile time. Tools such as language
servers could show these tighter constraints to the programmer. The final
solution is to require an explicit tighter constraint, through some sort of new
syntax, e.g.:

\golisting{./examples/expressions/headtailexplicit.go}

Which places a lower bound of 1 on the \kw{const} interface using the well-known
slicing notation. What about when two distinct type parameters appear in a
``constant'' expression, such as in the (somewhat contrived) example below:

\golisting{./examples/expressions/difference.go}

This code is only safe to execute when $N \ge M$. This adds additional
complexity, as we need to extend our approach from before, if we wish to pursue
the liberal approach. In the implicit model, the compiler would have to reject
all instantiations of the function where $N < M$. In the explicit model, the
slicing notation would be allowed to accept constant expressions, and since type
parameters are constant expressions, they could be used to explicitly constrain
the type parameters. Go already permits referencing other type parameters,
including the one that is being constrained, in the constraint of a type
parameter. The compiler would still need to verify that the bounds specified by
the programmer make the operation legal for all instantiations.

\golisting{./examples/expressions/differenceexplicit.go}

The downside of the liberal model, is that it makes the compiler implementation
significantly more complex, since it needs to determine what (if any)
combination of numerical type parameter values/ranges will type-check, for every
possible constant (compile-time) operation (e.g. plus, times, bitwise XOR, type
conversion etc.).
% TODO one or two examples:
% one similar to Axel's using existing operations
% one nested example, i.e. a constrained numerical type parameter is the target
% (e.g. factorisation)
It can be shown that such checks could be used to perform computation at
compile-time, e.g. to solve SAT formulas \autocite{goArraySAT}, which can
undermine Go's promise of fast compile times, if the programmer (accidentally or
deliberately) misuses the type system. As such, in practice, the most reasonable
roadmap to implement numerical type parameters in Go would be to start with the
conservative approach, then progress to an explicit liberal model, and finally,
if there is demand for it, consider the implicit liberal model, as a type
inference feature. Due to the complexity of the liberal model, Rust has also
opted for the conservative approach for the time being \autocite{rustConstBlog}.

Investigating in detail the feasability and safety of the liberal approach
is a topic for future work. The following sections of this work consider the
conservative model only.

% Another complexity of handling the liberal approach, is recursion, and its
% potential for code bloat...
% TODO
% approaches: forbid recursive calls with different numerical type params
% compare with existing. Conservative approach does not have this problem.
% Can explore the explicit liberal model? (i.e. that could bound the max
% recursion depth, and hence the programmer explicitly controls the code bloat,
% again language servers could report the number of instantiations of a function)

% How do we handle overflow? (at call site? implicit upper bound, e.g. if 2N is
% used internally, then maximum is MaxInt/2, i.e. the type parameter is a
% subtype of the union of all integers, i.e. a subtype of const, despite being
% bound by const). Compiler could report in error the
% implicit upper bound.

% language servers could show the upper bound to the programmer

% an extension would be explicit bounds (both lower, permitting indexing, and
% upper), although it's hard to say if this feature would be useful enough to
% add to the language, given Go's idealogy of simplicity and minimalism.

% if we don't allow complex expressions, then there is no overflow problem

% TODO sizeof generic type? Is this const? If not, then Go already follows the
% conservative approach.


% N -> constant
% N + 1 -> non-constant
% op(Type(N)) -> non-constant, e.g. len([N]T)
% (i.e. analogous to rust)

% TODO move this section above len section, since the len section references
% points introduced in this section

% Maybe we allow complex expressions for non-recursive structures? Go already
% does recursion detection in the compiler

% Evaluate both conservative (Rust) and permissive (Werner) approaches

% Discuss code bloat concerns


\subsection{The \texttt{len} function}

Go's built-in \texttt{len} function is special in the sense that depending on
the context, it may or may not be computed at compile time \autocite{spec}. If
it is computed at compile time, we can assign the result to a \kw{const}
variable, or use it in any other place that requires a compile-time constant
non-negative integer value, such as for the length of an array.

An example of a compile-time evaluation of \texttt{len} is when it is applied to
an array value literal, and an example of a run-time evaluation of \texttt{len}
is when it is applied to a slice value. The question arises, how should
\texttt{len} treat generic arrays (specifically, ones that are parameterised on
size)?

If we take Rust's conservative approach of prohibiting the use of expressions
that include constant type parameters (except when the expression is a lone type
parameter) as type arguments, which include applying \texttt{len} to a
generically sized array, then it becomes clear why \texttt{len} of a generically
sized array should yield a non-constant integer (as indeed is the case in Rust).
Without this restriction, the compiler would have to keep track of which
constant was derived from an expression containing a type-parameter, to prevent
the later usage of such a constant in another const expression used as a type
argument.

% TODO include code examples demonstrating the problem

In fact, if we view the generally sized arrays as the union of array types of
all sizes (similar to the explicitly enumerated array type union we can already
represent in code), then we can keep things as they are currently in Go. I.e. a
generic type bound by a union of arrays has a non-constant \texttt{len}:

\golisting{./examples/werner/const_len_of_interface.go}

This is likely to avoid constraining the compiler implementation. With a full
monomorphisation approach, the \kw{const} of the example above is not an issue,
as each instantiation of the function has its own local \texttt{const n} with a
distinct value. However, in the current GC Shape Stenciling approach used by the
Go compiler as of Go 1.18 \autocite{generics1.18}, it is possible to construct a
union of array types that are have the same GC shape, yet the length of the
array type differs. In such cases, \kw{const}s within a generic function would
be difficult or even impossible to handle correctly. A simpler explanation, is
that generic types simply always have non-constant lengths (given \texttt{len}
is defined on all types of the type set), regardless of whether or not values of
their constraint type could yield a constant length, \autocite{spec}.

\subsection{Allowed operations on generic arrays}

% casting length to a value other than int is forbidden, as it must statically
% type check with any instantiation (of any size, including MaxInt), same
% applies to casting type parameter

% casting type param to value other than int is also forbidden
% 
% casting to an array using type parameter (or derived len) is also forbidden
% 
% indexing in an array using a type parameter is forbidden (unless it is
% assigned to non-const int variable first) - this is backwards incompatible
% with treating len([N]T) or N as int! rather than making it illegal, we can
% make it an allowed, run-time checked operation to ensure backwards compatibility

% i.e. we must differentiate between true-const, and generic-const values in the
% compiler. One has restrictions, the other does not.

% alternatively we perform casts at runtime on the generic-const values. The
% compiler already does not treat len of calls to array returning function a
% constant, so why should it perform casts of generic-const values at compile
% time?

% similar argument could be made for constant indexing into generic arrays, move
% the check to runtime, however this is incosnsitent

% if someone is smart enough to SAT solve at compile time, should we even worry
% about them?

% if len and type param evaluate to constant values, than that constant may only
% be cast to int (avoids SAT problem:
% https://github.com/golang/go/issues/44253#issuecomment-821047754)

% indexing with constant is forbidden, as it must statically type with any
% instantiation (of any size, including 0)
% this is consistent with existing union type implementation

\subsection{Summary of proposal}

% Rust's conservative approach avoids many problems (which are not unsolvable,
% but rather more work). We can always introduce the permissive approach later.

% Coin the conservative and liberal terminology for numerical type parameters
