\section{Featherweight Generic Go with Arrays}
\label{ch:fgg}

\emph{Featherweight Generic Go} (FGG) is an extension to \emph{Featherweight Go}
that introduces generics via type parameters, formalised in \autocite{fg}. This
section adapts FGG with the syntax and restrictions introduced in the Type
Parameters Proposal and ultimately implemented in Go v1.18
\autocite{genericsProposal}, and extends it with arrays and numerical type
parameters that can be used to create generic array types, referred to as FGGA
going forwards.

Rules or rule fragments that remain unchanged from FGA are shown in grey,
whereas new rules or rule modifications are shown in black.

\subsection{FGGA Syntax}

Syntactically, a type is now one of 4 things --- it is either a type parameter,
which is just an identifier, an integer literal, the keyword $\const$ (which
cannot be used as a regular type in user programs) or a named type. Named types
are defined in terms of type names from FGA, with the addition of a sequence of
zero or more type arguments enclosed in square brackets, following the type
name. The type arguments are themselves types. While it's not explicitly stated
in figure \ref{fig:fgg-syntax}, when there are no type arguments, the square
brackets \emph{must} be omitted, to ensure compatibility with Go. The
consequence of this is that syntactically, there is no way to differentiate
between a type parameter and a named type with no type arguments. A value type
is a named type whose base type name (i.e. outermost type name) is a value type
name. The situation is analogous for interface types. An interface-like type is
either an interface type or a type parameter, which is used for interface-like
type assertions. An integer-like type is either an integer literal, or a type
parameter, and can be used as the size of an array type literal. A bound is used
to restrict the set of type arguments that can be used in place of a type
parameter. A type parameter constraint $\Phi$ is used to define a type parameter
along with its constraint (bound).

Method signatures, struct type literals, array type literals and value literals
are updated to used types in the place of type names. Type declarations now have
a sequence of type parameter constraints following the type name, that are
required when instantiating the type. Similarly to type arguments, a type with
no type parameters \emph{must} omit the square brackets.

Unlike in FGG, method receivers are invariant, as such, there is no need to
repeat the type parameter constraints on the receiver type parameters. Instead,
a simple type parameter sequence is used. In Go, these type parameters can be
named differently from type parameters in the type declaration, since the order
of the parameters is sufficient to identify them, however, to keep the rules
simpler, in FGGA the type parameter names must match exactly with the ones
specified in the type declaration. Another feature omitted from the current
implementation of generics in Go, but present in FGG, are method-specific type
parameters. In order to be compatible with the current implementation, these
constructs are also omitted from FGGA.

\input{../../projects/go-generic-array-sizes/theory/fgg-syntax}

\subsection{FGGA Reduction}

The reduction rules for FGGA are nigh identical to the ones found in FGA, with
the only notable difference being that type names $t$ are replaced with types
$\tau$.

More interesting differences occur in the auxiliary functions. In FGA,
$\indexbounds$ took a type name and performed a simple lookup in the type
declaration to extract the size of the array. In FGGA, there are two cases of
the $\indexbounds$ function. When the size of the array type is an integer
literal, then the bounds are calculated in the same way as in FGA, based on a
lookup of the named type declaration of the array type. If however, the array
type declaration has a type parameter in place of the array size, then the
bounds are calculated from the integer literal type argument in the array type
that corresponds to the type parameter used as the array size in the
declaration. The correspondence is determined by matching on the same position
in the sequence of type parameter constraints and the sequence of type
arguments.

The $\mbody$ auxiliary function has also been updated to perform substitution of
method type parameters with the receiver's type arguments within the method
expression. A map within a pair of double square brackets applied to a term
(e.g. $e\llbracket\theta\rrbracket$ in the $\mbody$ function) denotes a
substitution application in this and following rules. The type arguments are
mapped to the type parameters based on their respective positions.

Similarly, the $\fields$ auxiliary function has been updated to perform a type
parameter substitution with type arguments on the resulting struct fields. This
is performed analogously to how it's done in the $\mbody$ function, except that
type parameters are extracted from the type parameter constraints in the struct
type declaration.

\input{../../projects/go-generic-array-sizes/theory/fgg-reduction}

\subsection{FGGA Typing}

$\Delta$ is defined as a typing environment mapping type parameters $\alpha$
to their bounds $\gamma$. Type parameter constraint sequences $\ov{\Phi}$ may
implicitly coerce to type environments. As before in FGA, $\Gamma$ is defined as
an environment mapping variables $x$ to types $\tau$.

The ``implements'' relation now includes a typing environment $\Delta$. As
before, all types implement themselves (rules $\imp_{\text{Param}}$, $\imp_V$,
$\imp_{int}$, $\imp_{const}$ and $\imp_n$), and integer literal types implement
the \kw{int} type (rule $\imp_{int-n}$). Non-negative integer literals now also
implement the \kw{const} type (rule $\imp_{const-n}$), so that they can be used
as type arguments, where the bound of the type parameter is \kw{const}. Since
the use case of numerical type parameters is to generically size arrays, and
arrays cannot be of a negative size, negative integers do not implement
\kw{const}.


The $methods_\Delta$ auxiliary now also accepts a typing environment as input
(denoted by a subscript $\Delta$), as a type parameter bound lookup may be
necessary to retrieve the methods of a type. For a named value type
$t_V[\ov{\tau}]$ $\methods_\Delta$ returns the set of method specifications of
the base value type $t_V$, with type substitutions performed on them. E.g. if
the declared value type \texttt{Foo} with a type parameter \texttt{T} has a
method with the specification \texttt{f(x T) T}, then
$\methods_\Delta(\texttt{Foo[int]})$, where $\Delta$ is any typing environment
(as it is not relevant in the case of looking up methods of a named value type),
would return \{(\texttt{f(x int) int})\}. The implication of this is that one
instantiation of a generic type could implement a certain interface, while
another could not, depending on the type arguments. A $\methods_\Delta$ lookup
on an interface has similarly been updated to return a type-substituted method
set. Additionally, the method set of a type parameter $\alpha$ is equal to the
method set of its bound $\gamma$, as specified in the typing environment
$\Delta$.

The $\methods_\Delta$ auxiliary is now a partial function, not defined on the
\kw{const} type. This is because there is currently never a context in which the
$\methods_\Delta$ would need to be applied to \kw{const}. In a future extension,
type parameters bounded by \kw{const} could be used as expressions (since they will
be instantiated with integer values in user programs), in which case we could
define $\methods_\Delta(\const) = \{\}$ so that they implement the empty
interface. We could then additionally have a rule stating that type parameters
bounded by \kw{const} implement \kw{int}.

Because $\methods_\Delta$ is not defined on \kw{const}, there is an additional
subtyping rule that specifies that type parameters which are bound by
\kw{const}, are also subtypes of \kw{const} (rule $\imp_{const-\text{Param}}$).
All type parameters are subtypes of their bounds, but where the bounds are a
regular interface (i.e. not \kw{const}), this can already be derived via the
$\imp_I$ rule.

The integer literal type can now appear in user programs, although with
restrictions as to where they can be used. They can only be used as type
arguments in a named type and as the size parameter of an array type literal but
not e.g. as a standalone type of a variable or a return type. Const type
parameters (i.e. those that are bound by \kw{const}) have the exact same
restrictions as integer literal types. To distinguish between these two kinds of
user-program types, the $\isconst_\Delta$ predicate was created, which simply
checks if the type is a subtype of \kw{const}. Because both \kw{const} type
arguments and array sizes must be non-negative, we can also restrict all integer
literal types to be non-negative (rule T-N-Type).

A type parameter $\alpha$ is considered well-typed if it appears in the typing
environment $\Delta$ (rule T-Param). The rule T-Named has been updated to
type-check each type argument in the named type, recursively applying one of
``well-formed type'' rules ($\Delta \vdash \tau \ok$) on each argument, and
checking whether each argument satisfies the type parameter bound via the
$(\ov{\Phi \by_\Delta \tau})$ lookup. The lookup differs from the regular type
substitution map lookup (denoted without the subscript $\Delta$), that it
additionally checks the bounds of each type argument via the subtyping relation,
which itself is done via a type substitution on the type parameters as well as
the bounds, because bounds may refer to other type parameters in the type
parameter constraints sequence. Not only must the type arguments implement the
type-substituted bounds of their corresponding type parameters, but they must
also have an equal ``\kw{const}-ness'', i.e. either both the argument and bound
return true for $\isconst$, or they both return false. The need for this check
can be illustrated with the following example: $2 \imp \texttt{any}$ holds, but
2 cannot be used as a variable type, and so it cannot be used to instantiate a
type parameter bound by \texttt{any}. This is enforced in the rule because
$\isconst_\Delta(2) \neq \isconst_\Delta(\texttt{any})$. Both the type-checking
and non type-checking lookups yield a map from type parameters to types, denoted
by $\eta$.

The rule T-Formal specifies what it means for type parameter constraint
sequences (i.e. the formal type parameters found in a type declaration) to be
well typed. All type parameters must be distinct, and their bounds must be
well-typed, in the context of the typing environment that is created from the
type parameter constraints that are being checked. This environment is necessary
for recursively defined type parameter bounds, e.g. if \texttt{Eq} is an
interface with one type parameter, then we can define another type \texttt{Foo}
with a type parameter $\alpha$ bound by \texttt{Eq[$\alpha$]}, i.e. the type
parameter is referenced within its own bound.

There is a restriction in the current implementation of Go, that FGGA also
adheres to, and that is that no type in any type parameter bound can refer to
the type being declared (directly or indirectly). E.g. the interface type
declaration \texttt{Eq} cannot have a type parameter $\alpha$ bound by
\texttt{Eq[$\alpha$]} itself \autocite{spec}. An example of how to get around
the self-recursive bound limitation in practice can be found in the
\hyperref[sec:self-ref-type-in-bound]{appendix}.
% TODO what about indirectly recursive types? any use cases? if so, any
% workarounds?
The check for this restriction is performed via the $\notref$ auxiliary in the
T-Type rule for each type parameter bound $\gamma$. $\notref$ is defined
recursively, with the recursive case existing for named types $t[\ov{\tau}]$,
and the base cases are the remaining type kinds; integer literals cannot be used
as a type name, and neither can the keyword \kw{const}, so there is no
possibility of a self-reference for those types. If a type is named the same as
a type parameter, the type parameter will shadow the type name, and no
self-reference occurs.
% TODO verify this is the case in Go (shadowing of type name with type param,
% both for self and non-self referential)
When checking for self-reference in a named type, first we check whether the
named-type's type name $t$ is equal to any of the types we have already seen
$\ov{t_r}$. Initially, the seen types sequence only contains the type we are
type checking in T-Type. $\notref$ is performed recursively on all type
arguments, as those could also be referencing one of the types from $\ov{t_r}$.
To detect indirect self-references (i.e. circular references), $\notref$ is
applied on all type parameter bounds of the named type's declaration, appending
the type name $t$ to the sequence of seen type names $\ov{t_r}$ to check for
self-references. While theoretically, we could have just a single type $t_r$ to
check for at a time, rather than a sequence, this would lead to problems when
checking types that are self-referential, but do not contain the initial type
$t_r$ in the cycle, as the rule would recurse indefinitely. Examples of the
$\notref$ auxiliary being used to type-check type declarations and a detailed
illustration of the issue of checking a single type $t_r$ at a time can be found
in the \hyperref[sec:fgg-self-ref-derivation-examples]{appendix}.

The remainder of the T-Type rule checks that the type declaration's type
parameters constraints $\ov{\Phi}$ are well-formed (via T-Formal), and that the
type literal is well-typed in the typing environment formed from $\ov{\Phi}$.

The rule T-Const asserts that \kw{const} type passes the bounds type check in
the T-Formal rule in any environment $\Delta$. The T-Specification rule has been
updated to type check the parameter and return types under the typing
environment $\ov{\Phi}$. Additionally, neither the parameter nor return types
may be \kw{const} types. T-Struct has similarly been updated to check the field
types in the environment $\ov{\Phi}$, and to only permit non-\kw{const} field
types. An array size can now be any valid \kw{const} type, and the element type
must be a valid non-\kw{const} type, evaluated in the typing environment
$\ov{\Phi}$. The T-Func and T-Func-Arrayset rules have been updated to look up
the type parameter constraints based on the receiver type parameters to
construct typing environments for the updated type-checking rules.

Rules T-Int-Literal, T-Var, T-Call, T-Struct-Literal, T-Field and T-Program are
all updated to use types $\tau$ and typing environments $\Delta$. The $\lentype$
auxiliary now has two cases. One as before: when the array size is an integer
literal (i.e. non-generic). The other is the generic case, where the array size
is a type parameter, in which case $lentype$ returns the type argument that is
used to instantiate the array size type parameter (by matching on the type
parameter position). Array literals in FGGA can only be constructed when the
$\lentype$ is an integer literal type --- either when the array length type is
non-generic, or has been instantiated with an integer literal (rule
T-Array-Literal). When the array size is instantiated with a type parameter, the
size is unknown, hence it is not safe to assume the array can hold any elements
(e.g. it could be instantiated later with a size of 0). In practice, Go's zero
values could be used to instantiate generically sized arrays, but since FGGA
does not support them, even empty generic array initialisation is not allowed.
The supertype of an array literal's elements is determined by type parameter
substitution on the array's element type.

As before, there are two rules for performing an array index operation, one
where the type of the index is \kw{int}, and one where the type is an integer
literal (rules T-Array-Index and T-Array-Index-Literal). It is worth noting that
generic, non-instantiated arrays (i.e. where $\lentype$ does not return an
integer literal) can only be indexed using a non-constant integer of type
\kw{int}. This is to stay consistent with current expectations: indexing into an
array using a constant integer literal is only allowed to fail at compile-time.
In line with the Go spirit of type-checking generic code at the declaration
site, as opposed to the call site, indexing into generic arrays using integer
literals is not allowed in FGGA, even if the index would remain within bounds
for all array instantiations in the scope of the current program. The programmer
may still achieve such behaviour by explicitly assigning the integer literal to
a non-const \kw{int} variable and then performing an index operation.

\input{../../projects/go-generic-array-sizes/theory/fgg-aux}
\input{../../projects/go-generic-array-sizes/theory/fgg-typing}

\subsection{FGGA Properties}

As before, an array index expression or an array-set method call expression
panics if they contain an array type $\tau_A$, and an array index $n$, where $n
    \notin \indexbounds(\tau_A)$. An expression $e$ panics if $e = E[d]$, where $E$ is
any evaluation context, and $d$ is an expression that panics.

The progress and preservation properties covered in \emph{Featherweight Go}
apply to FGGA and are defined as follows \autocite{fg}:

\begin{theorem}[Preservation]
    If\/ $\emptyset;\emptyset \vdash d : \sigma$ and $d \becomes e$
    then\/ $\emptyset;\emptyset \vdash e : \tau$ for some $\tau$
    with\/ $\tau \imp \sigma$.
\end{theorem}

\begin{theorem}[Progress]
    If\/ $\emptyset;\emptyset \vdash d:\sigma$ then
    either\/ $d$ is a value,
    $d \becomes e$ for some $e$,
    or\/ $d$ panics.
\end{theorem}
