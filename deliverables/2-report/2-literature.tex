\section{Background Research}

\subsection{Generic array sizes in other languages}

Languages where the size of an array is not part of its type (e.g. Java, C\#),
automatically abstract over arrays of all sizes, as there is no way of
expressing that a variable holds an array of a specific size.

In C, macros can be used to achieve a form a generic programming, which includes
the ability to parameterise the size of an array forming part of its type (see
\hyperref[sec:generic-c]{code example in appendeix}).

\subsubsection{Const generics in Rust}

In Rust, arrays are treated very similarly to how they're treated in Go: arrays
are value types and the size is part of the array's type. As such, developments
of arrays in Rust are of particular interest when designing the generic
extension in Go. In particular, \emph{const generics} have already been
introduced to Rust, facilitating parameterisation over array sizes
\autocite{rustConstBlog}.

The syntax introduces the \texttt{const} keyword in the type parameter list,
followed by the type parameter name and its bound (same as for non-constant type
parameters). The current implementation only permits integral types for the
bounds of const type parameters, which is reasonable given that the main
rationale for const generics is to be able to parameterise over array sizes. The
authors could have limited const generics to the \texttt{usize} type (the type
used for array sizes in Rust), however they claim it would have not made the
implementation simpler \autocite{rustConstRFC}. Since Go puts a strong emphasis
on language simplicity \autocite{goSimplicity}, this work proposes to limit
constant generics in Go to only accept integral type parameters of the same type
that can be used as array sizes, i.e. ``a non-negative constant representable by
a value of type \texttt{int}'' \autocite{spec}. The implication of this design
decision is that the syntax can be simplified, as \texttt{const} can be made to
imply the array-length type described by the Go specification.

Rust imposes limitations on constant type arguments for ease of implementation.
In particular, expressions including a const parameter (with the exception of a
lone const parameter) are not permitted as type arguments. In the
monomorphisation model of generics, recursive definitions with const type
argument expressions containing const type parameters could lead to extreme code
bloat in the compiled binary. Another issue would be the potential for the const
type argument to go out of bounds (e.g. less than 0 as a result of a subtraction
operation on the type parameter). The simple solution is to not permit such type
arguments. This insight can be carried over to the Go design. The simplicity of
the feature with this constraint also aligns with the ethos of Go
\autocite{goSimplicity}.

% TODO create semi-realistic code examples for problematic expressions with
% const type parameters (can adapt example from
% https://github.com/golang/go/issues/44253)

\begin{figure}
    \begin{lstlisting}
struct ArrayPair<T, const N: usize> {
    left: [T; N],
    right: [T; N],
}
\end{lstlisting}
    \caption{Example of const generics for arrays in Rust \autocite{rustConstBlog}}
\end{figure}


While Rust implements generics using monomorphisation
\autocite{rustCompilerGuide}, Go uses a hybrid of monomorphisation and
dictionary-passing \autocite{generics1.18}. Further investigation needs to be
undertaken to determine whether this difference affects how constant type
parameters could be implemented in Go, such as potentially lifting the
constraint on recursive constant type parameter expressions.

\subsection{Type systems and programming language theory}

\citeauthor{tapl} covers core topics in programming languages and type theory
including how to precisely describe the syntax, evaluation and static type
system of programming languages, and techniques for proving properties of those
language (\citeyear{tapl}). The book formally presents the notion of language
type safety consisting of \emph{progress} and \emph{preservation}.

The progress theorem says that well-typed terms (i.e. those that are in the
typing relation defined by the typing rules) do not get ``stuck'', i.e. they are
either terminal values or can take a reduction step, as defined by the reduction
(evaluation) rules.

The preservation theorem says that if a term is well-typed, then it will
continue to be well-typed after a reduction step. Depending on the language,
the type system may impose further restrictions on this theorem, e.g. that
the type of the term after taking a step is exactly the same type as before
the step, or that it is a subtype of the type before the step.

To summarise, if we have a term that is well-typed, then by the preservation
theorem, it will continue to be well-typed no matter how many reduction steps
are taken. Together with the progress theorem, we know that the term will always
be able to take a reduction step (because it is well-typed after each one) until
it reaches a terminal value. In other words, the well-typed term will never get
``stuck'' during execution. These theorems can be used to prove the soundness of
a type system, which is fundamental for any well-designed type system, including
the one proposed in this work.

The book also presents how to conduct such proofs, namely using a technique
called \emph{structural induction}. Structural induction is analogous to
induction on natural numbers, except that it works on recursively defined
structures, such as those found in the formal rules of programming languages.

\subsection{Featherweight Go}

For many years, the biggest criticism against the Go language was the lack of
generics \autocites{survey2021}{survey2020}{survey2019}. The Go team recognised
the importance of solving this problem ``right'' and consequently reached out to
the world of academics for a collaboration, the result of which was a paper
named \emph{Featherweight Go} \autocite{fg}. The work was inspired by
\emph{Featherweight Java}, an effort two decades prior aimed at formalising Java
and its generic extension \autocite{fj}. The common theme in the two papers is
the reduction of the programming language into a small core ``featherweight''
subset, making it easier to prove properties about the language and,
subsequently, any proposed extensions.
% TODO why is it important to proove properties of a language?
Both papers also extended their language subsets into variants with generics
(parametric polymorphism), and showed how the generic variant can be translated
into the non-generic base language.

\emph{Featherweight Go} formalises a subset of Go through syntax, reduction and
typing rules, as well as an extended variant with generics. They are used the
starting point for the formal rules in this work. In their work, \citeauthor{fg}
proove the soundness of the FG and FGG type systems using the progress and
progress theorems described in the previous section.

\citeauthor{fg} argue that both ``featherweight'' and ``complete'' descriptions
of languages have value. This work will follow the featherweight approach, since
it was a successful strategy in the case of \emph{Featherweight Go}, aimed at
introducing a new feature to the language, and keeps the focus on the parts of
the language that matter most when making the addition.

Because the \citetitle{genericsProposal} (implemented as of Go 1.18) only
includes a subset of the generic extension features described in
\emph{Featherweight Go}, this work will use that reduced description, both for
simplicity and to better mirror the state of generics in current-day Go
\autocite{genericsProposal}.

\emph{Featherweight Go} also fully implemented the described languages as
interpreters to test that all presented examples work as expected. This work
intends to follow in the footsteps of \citeauthor{fg} in this regard.

% TODO mention the monomorphiser
