\section{Background Research}

\subsection{Generic array sizes in other languages}

Languages where the size of an array is not part of its type (e.g. Java, C\#),
automatically abstract over arrays of all sizes, as there is no way of
expressing that a variable holds an array of a specific size.

In C, macros can be used to achieve a form a generic programming, which includes
the ability to parameterise the size of an array forming part of its type (see
\hyperref[sec:generic-c]{code example in appendeix}).

\subsubsection{Const generics in Rust}

\subsection{Type systems and programming language theory}

\citeauthor{tapl} covers core topics in programming languages and type theory
including how to precisely describe the syntax, evaluation and static type
system of programming languages, and techniques for proving properties of those
language (\citeyear{tapl}). The book formally presents the notion of language
type safety consisting of \emph{progress} and \emph{preservation}.

The progress theorem says that well-typed terms (i.e. those that are in the
typing relation defined by the typing rules) do not get ``stuck'', i.e. they are
either terminal values or can take a reduction step, as defined by the reduction
(evaluation) rules.

The preservation theorem says that if a term is well-typed, then it will
continue to be well-typed after a reduction step. Depending on the language,
the type system may impose further restrictions on this theorem, e.g. that
the type of the term after taking a step is exactly the same type as before
the step, or that it is a subtype of the type before the step.

To summarise, if we have a term that is well-type, then by the preservation
theorem, it will continue to be well-typed no matter how many reduction steps
are taken. Together with the progress theorem, we know that the term will always
be able to take a reduction step (because it is well-typed after each one) until
it reaches a terminal value. In other words, the well-typed term will never get
``stuck'' during execution. These theorems can be used to prove the soundness of
a type system, which is fundamental for any well-designed type system, including
the one proposed in this work.

The book also presents how to conduct such proofs, namely using a technique
called \emph{structural induction}. Structural induction is analogous to
induction on natural numbers, except that it works on recursively defined
structures, such as those found in the formal rules of programming languages.

\subsection{Featherweight Go}

For many years, the biggest criticism against the Go language was the lack of
generics \autocites{survey2021}{survey2020}{survey2019}. The Go team recognised
the importance of solving this problem ``right'' and consequently reached out to
the world of academics for a collaboration, the result of which was a paper
named \emph{Featherweight Go} \autocite{fg}. The work was inspired by
\emph{Featherweight Java}, an effort two decades prior aimed at formalising Java
and its generic extension \autocite{fj}.
The common theme in the two papers is the reduction of the programming language
into a small core subset, making it easier to prove properties about the
language and, subsequently, any proposed extensions.
% TODO why is it important to proove properties of a language?
Both papers also extended their language subsets into variants with generics
(parametric polymorphism), and showed how the generic variant can be translated
into the non-generic base language.

% TODO talk about contracts and then how Featherweight Go simplified it and
% convinced the team
