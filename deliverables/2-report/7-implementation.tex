\section{Implementation}
\label{ch:interpter-impl}

As part of this work two interpreters were implemented, one for FGA and one for
FGGA. In addition, a monomorphiser was implemented translating FGGA to Go. The
output of the monomorphiser is a valid subset of FGGA, so it can be interpreted
by the FGGA interpreter as well as compiled by the official Go compiler.

A similar set of programs were found in the set of artifacts in Featherweight Go
\autocite{fg} - interpreters for the two languages formalised, and a
monomorphiser translating generics (the feature introduced by Featherweight Go)
into code that the official Go compiler at the time could handle.

\subsection{Libraries and patterns}

ANLTR\footnote{\href{https://www.antlr.org/}{ANLTR: https://www.antlr.org/}} was
used to generate the parser, and the interpreters and monomorphiser were
implemented in Go itself.

The visitor pattern was heavily employed throughout the code for operations
including building the abstract syntax tree (AST), preprocessing to remove
ambiguity resulting from the grammar (as discussed in section
\ref{sec:fgg-syntax}), type checking, reduction, monomorphisation, and various
other auxiliary operations. The pattern makes it easy to recursively traverse
the AST and apply the desired operation.

% The operation is applied at certain base cases, and the visitor can keep track
% of the parent's context, which is passed along (with potentially more data) at
% each level of recursion

It allows for the separation of concerns, i.e. each operation can live in its
own package. Simply defining methods on the AST would force all operations to be
defined in a single package (in Go, methods on a type can only be defined in the
same package the type is declared), limiting the code organisation flexibility.

% It is extensible, e.g. multiple different operations can implement the same
% visitor interface, provided the return types align. Because often they don't
% align (e.g. some operations can error, while other cannot), in practice
% multiple visitor interface variants were created. Additionally, in some cases,
% it was only desired to traverse a subtree, hence not all ast node types needed
% to be visited, and so special purpose subtree visitors were also created.

% The downside of the visitor pattern is that it produces a bit of boilerplate
% code, however, IDEs make it easy to generate, and we can shove it all away
% into ``biolerplate.go'' and only worry about the actual functionality.

% Another downside is the proliferation of type casts (assertions).

% TDD allows for fearless refactoring, as all written "features" are covered by
% tests from the start - such a refactoring was undertaken - moving the type
% parameter substitution from an ad hoc basis to a separate preprocessing step
% before any type checking started

% Another core part of the implementation was coming up with edge cases, writing
% tests to check how the interpreter behaved, and if necessary updating the
% formal rules to cover the edge case. E.g in FGGA the `notReferenced' auxiliary
% had to be updated to instantiate the type literals it recursively checks
% checks, as a result of the described process.

% projects/go-generic-array-sizes/interpreters/fgg/typecheck/testdata/self_ref/self_ref_in_type_arg

% In fact, following this process a bug in the official Go compiler (as of Go
% 1.21.3) was caught, which caused the compiler to crash due to stack overflow.

% projects/go-generic-array-sizes/interpreters/fgg/typecheck/testdata/self_ref/self_ref_indirect/self_ref_indirect.go

% Some snippet of testing (TestMonomorphise_givenStructFieldOfConstGenericArrayType):
% Diff:
% --- Expected
% +++ Actual
% @@ -8,3 +8,3 @@
% type Foo__2 struct {
% -	x Arr__2[int]
% +	x Arr[N, int]
% }
