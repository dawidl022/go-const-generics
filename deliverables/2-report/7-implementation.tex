\section{Interpreter Implementation}
\label{ch:interpter-impl}

% visitor pattern makes it easy to recursively traverse the AST and apply a
% certain operation (e.g. reduction, type checking, or preprocessing)

% The operation is applied at certain base cases, and the visitor can keep track
% of the parent's context, which is passed along (with potentially more data) at
% each level of recursion

% It allows for the separation of concerns, e.g. each operation can live in its
% own package. Simply defining methods on the AST would force all operations to
% be defined in a single package, limiting the code organisation flexibility

% It is extensible, e.g. multiple different operations can implement the same
% visitor interface, provided the return types align. Because often they don't
% align (e.g. some operations can error, while other cannot), in practice
% multiple visitor interface variants were created. Additionally, in some cases,
% it was only desired to traverse a subtree, hence not all ast node types needed
% to be visited, and so special purpose subtree visitors were also created.

% The downside of the visitor pattern is that it produces a bit of boilerplate
% code, however, IDEs make it easy to generate, and we can shove it all away
% into ``biolerplate.go'' and only worry about the actual functionality.

% Another downside is the proliferation of type casts (assertions).

% TDD allows for fearless refactoring, as all written "features" are covered by
% tests from the start - such a refactoring was undertaken - moving the type
% parameter substitution from an ad hoc basis to a separate preprocessing step
% before any type checking started

% Another core part of the implementation was coming up with edge cases, writing
% tests to check how the interpreter behaved, and if necessary updating the
% formal rules to cover the edge case. E.g in FGGA the `notReferenced' auxiliary
% had to be updated to instantiate the type literals it recursively checks
% checks, as a result of the described process.

% projects/go-generic-array-sizes/interpreters/fgg/typecheck/testdata/self_ref/self_ref_in_type_arg

% Some snippet of testing (TestMonomorphise_givenStructFieldOfConstGenericArrayType):
% Diff:
% --- Expected
% +++ Actual
% @@ -8,3 +8,3 @@
% type Foo__2 struct {
% -	x Arr__2[int]
% +	x Arr[N, int]
% }
