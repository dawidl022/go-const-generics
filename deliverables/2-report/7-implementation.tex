\section{Interpreter Implementation}
\label{ch:interpter-impl}

% visitor pattern makes it easy to recursively traverse the AST and apply a
% certain operation (e.g. reduction, type checking, or preprocessing)

% The operation is applied at certain base cases, and the visitor can keep track
% of the parent's context, which is passed along (with potentially more data) at
% each level of recursion

% It allows for the separation of concerns, e.g. each operation can live in its
% own package. Simply defining methods on the AST would force all operations to
% be defined in a single package, limiting the code organisation flexibility

% It is extensible, e.g. multiple different operations can implement the same
% visitor interface, provided the return types align. Because often they don't
% align (e.g. some operations can error, while other cannot), in practice
% multiple visitor interface variants were created

% The downside of the visitor pattern is that it produces a bit of boilerplate
% code, however, IDEs make it easy to generate, and we can shove it all away
% into ``biolerplate.go'' and only worry about the actual functionality.

% TDD allows for fearless refactoring, as all written "features" are covered by
% tests from the start - such a refactoring was undertaken - moving the type
% parameter substitution from an ad hoc basis to a separate preprocessing step
% before any type checking started
