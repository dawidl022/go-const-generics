\section{Arrays by Example}

Slices may be used for ..., this section intends to identify use cases, where
using arrays in Go programs may be more beneficial than using slices.

% Subsection 1: Gentle introduction

% Example 1: `reversed` function

% Show current workaround with "union-like" interfaces and discuss its
% limitations

% Subsection 2: Data-structure examples

% Example 2: Array struct with static capacity and len field

% Example 3: Ring buffer of static size

% Subsection 3: Operation examples

% Example 4: Usage of arrays and above data structures as map keys

% Example 5: Comparison of deeply nested structure possible with array, but not
% slices

% Example 6: Trivial deep-copies (via assignment/dereferencing) of deeply nested
% structures with arrays

% Subsection 4: Real-world use-case examples

% Any other examples from current issue and proposal

% Subsection 5: Benchmarks

% Benchmarks of all examples comparing arrays with slices, both using pointers
% to and copies of arrays, both large and small array sizes. Use escape analysis
% to see where arrays/slices are being allocated to.

% State machine used in benchmarks (potentially benchmark on amd64 as well as
% arm64)

% Subsection 6: Type-set interfaces and the \kw{const} interface

% conceptually: type const interface { 0 | 1 | 2 | 3 | ... }
% implementation: type const interface { const }, analogous to comparable interface

% TODO compare with existing proposal

% TODO explain in FGGA why const is not an interface - because FGGA only
% considers classic interfaces, not type-set interfaces, introduced in the type
% parameter proposal. Type-set interfaces have same restrictions as \kw{const},
% i.e. they can only be used as type parameter bounds
