\section{Arrays by Example}

Most of the time, Go programmers will use slices over arrays due to their
dynamic nature. However, when the size of a collection of elements can be
determined at compile time, there are certain benefits to using arrays. This
section intends to identify use cases where using arrays in Go programs may be
more beneficial than using slices, and what are the benefits and the performance
implications.

A major drawback.

\subsection{Gentle introduction}

The first function we'll examine is one that creates a reversed copy of an
array/slice. Below is a side-by-side view of the two functions: the first
operating on arrays, and the second operating on slices.

\golisting{../../projects/go-generic-array-sizes/benchmarks/benchmarks/reversed/arrays.go}
\golisting{../../projects/go-generic-array-sizes/benchmarks/benchmarks/reversed/slices.go}

The slice function is almost identical to the array function, except that we
need to explicitly allocate a new slice for the result. Arrays are value types,
so simply passing an array into a function (and similarly returning an array
from a function) creates a copy. For relatively small arrays (8MB in size or
less), the memory for the array copy is allocated on the stack. For slices
however, even for the smallest slices (of length 1 or more), the
\texttt{reversed} function allocates the new slice on the heap. This operation
is more expensive, and so, as the benchmarks show, the array variant of the
\texttt{reversed} functions performs on average around 50\% faster for arrays of
size 8MB or less. For very small arrays (64 \texttt{int}s or less), the
performance benefits or arrays for this operation are even more apparent. Once
the array reaches 16MB or more, the memory for the copy gets allocated onto the
heap, and in fact becomes slower than using slices. The benchmarks are limited
to 256MB, since at array sizes of 512MB the compiler rejects the program, since
it could potentially use up more than 1GB of stack space (we need to multiply
512MB by two since we are creating a copy of the array). So if collections of
such large sizes are necessary, slices are the only option. For smaller sizes,
however, arrays perform better.

The benchmarks were run on a single core, using \texttt{GOMAXPROCS=1}, and the
results of the functions were written to global variables, in an attempt to
prevent the compiler from eliminating the benchmarked code \autocite{benchPits}.

\begin{figure}
	\input{../../projects/go-generic-array-sizes/benchmarks/runner/outputs/reversed/ArraySlice/reversed}
	\caption{Comparison of \texttt{reversed} function benchmarks captured on
		Apple M1 Pro}
\end{figure}

The literal \texttt{N} in the array type refers to a constant, defined elsewhere
in the program. The function signature only accepts arrays of size \texttt{N},
despite the function body being generic enough that it could work on arrays of
any size. To illustrate the point, the next example will inline \texttt{N} with
an integer literal. The function also happens to only accept \texttt{int}
arrays, but this can easily be fixed using generic type parameters, introduced
in Go 1.18 (unfortunately, at the cost of some performance):

% TODO consider placing complete benchmarks in appendix
% TODO suggest benchmarks for more use-cases as part of further work, mention
% challenges of benchmarking in Go due to compiler optimisations of contrived
% usages. It may make more sense to benchmark components in context of real
% system, or be able to read Go's assembly code to see for oneself's whether
% the compiler optimised away their benchmarked code, or why certain code is
% faster than other code

\golisting{./examples/reversed/generic_type.go}

The implication of this is that for each different array size we want
to use the \texttt{reversed} operation on, we would have to write a new function
with the exact same code, or use a code generation tool to do this for us.

As of Go 1.18, there is a workaround that partially solves the above problem.
Interface types are now defined in terms of the more general notion of type
sets, as opposed to method sets pre Go 1.18 \autocites{spec}{specPre1.18}.
"General interfaces" were introduced, that can only be (as of Go 1.21) used as
type parameter constraints, and among its features is the ability to specify a
union of types. With this, we can define an interface in terms of the union of
differently sized array that we wish to use with our \texttt{reversed} function
\autocite{goArrayProposal}:

\golisting{./examples/reversed/union_type.go}

This approach still has limitations. Apart from the obvious burden of having to
update the \texttt{array} interface every time we use an array of a new size,
this model breaks down as soon as we wish to expose such a function as part of a
public API. There is no way of knowing ahead of time what array sizes a user may
wish to use, and enumerating them all is infeasible. Ideally we'd want a way to
abstract over arrays of any size.

% TODO benchmark reversing in place

\subsection{Array semantics}

% TODO reword this section to make it flow better, and avoid repetition

We've looked at an example where using arrays is faster than slices. In general,
it is difficult to reliably build array-based data structures that offer better
performance than slices, since all the operations need to be handwritten and
optimised. One rule of thumb, is that allocations (and therefore copies) are
faster for arrays than slices.

\subsubsection{Value type}

However, arrays offer other semantic differences, that may make it more
appealing to build data structures from for certain use cases. We've seen that
arrays are value types, and as such, copies can be easily made through simple
assignment to a variable or passing into a function. While cloning a single
slice is not much more difficult, if we have a large, nested data structure,
that is slice based, performing a deep-copy is a verbose and manual process
(there is no standard library deep-copy function as of Go 1.21). If instead the
data structure was array based, with no internal pointers (only potentially a
top-level pointer to the data structure), performing a deep-copy becomes
trivial.

\subsubsection{Comparison}

Arrays are comparable, while slices are not. Again, for a simple example, one
could define a function that compares the size and elements of a slices to
determine if two slices are equal in value (not reference). It is slightly more
difficult to do the same with a nested slice-based data structure (although this
time around, the standard library does provide \texttt{reflect.DeepEqual} with
some caveats),
% TODO describe null vs empty slice in footnote
a nested array-based data structure (with no internal pointers) can be simply
compared with the \texttt{==} operator.

This comparable attribute of arrays becomes extremely important when we wish to
use a collection of elements as a key in a hash map. Only comparable data
structures can be used as map keys, which means that arrays can be used as map
keys, while slices cannot. This also applies recursively, so slice-based data
structures cannot be used as map keys, while array-based ones can.

\subsubsection{Limitations}

The drawback of defining array-based data structures and operations on them, is
that the array sizes must be fixed at compile time. By making array sizes
generic, we can parameterize array-based data structures over many sizes known
at compile time, making them much more versatile. The following subsection
outlines some examples of array-based data structures, and then we proceed to
describe how numerical type parameters can resolve this limitation, and a design
for them.

\subsection{Data structure examples}

% Example 2: Array struct with static capacity and len field

% Example 3: Ring buffer of static size

% Subsection 3: Operation examples

% Example 4: Usage of arrays and above data structures as map keys

% Example 5: Comparison of deeply nested structure possible with array, but not
% slices

% Example 6: Trivial deep-copies (via assignment/dereferencing) of deeply nested
% structures with arrays

% Subsection 4: Real-world use-case examples

% Any other examples from current issue and proposal

% Subsection 5: Benchmarks

% Benchmarks of all examples comparing arrays with slices, both using pointers
% to and copies of arrays, both large and small array sizes. Use escape analysis
% to see where arrays/slices are being allocated to.

% State machine used in benchmarks (potentially benchmark on amd64 as well as
% arm64)

\subsection{Type-set interfaces and the \kw{const} interface}

We've already looked at type set based interfaces introduced in Go 1.18. If we
treat array sizes as types, then we now have a conceptual set of types 0, 1, 2,
3, etc. Similarly, we can conceptually define the \kw{const} type as the type
set of all array sizes:

\golisting{./examples/reversed/const_type.go}

Where the \texttt{...} means the pattern repeats for all the non-negative
integers. In practice, \kw{const} would be another ``special'' predeclared
interface type, just like the existing \texttt{comparable} that ``denotes the
set of all non-interface types that are strictly comparable'' \autocite{spec}.
Just like \texttt{comparable}, \kw{const} would be an interface that can only be
used as a type parameter constraint, and not e.g. as the type of a variable,
function parameter or return type.
This \texttt{comparable} interface is not defined in terms of regular Go code,
but rather exists on the level of the language itself. \kw{const} would follow
the same pattern. The choice of the identifier \kw{const} is to ensure backwards
compatibility with existing programs, as this keyword is currently not allowed
to be used as a type name. Just like a union type set, \kw{const} can be
instantiated with one of the elements of the union, i.e. a non-negative integer
literal. This restricts numerical type arguments to strictly compile-time
constant integers. Such a type parameter could then be used as the size of an
array. With such an extension, we can express the \texttt{reversed} function from
above as follows:

\golisting{./examples/reversed/const_generic_type.go}

Note how once again, the body of the function remains unchanged. The only
difference is that \texttt{N} is now a type parameter bound by the
\texttt{const} interface. The above function can operate on any array of any
size and any element type.

The rest of this work looks at the theory and implementation of the \kw{const}
type into the existing Go language. We will examine a language called
Featherweight Generic Go With Arrays (FGGA), which is a subset of Go, modulo the
addition of numerical type parameters. Since FGGA only considers ``classic''
(method set) interfaces, \kw{const} will not be an interface type in FGGA, but
rather in its own category. This category can be though of as non-method set
interfaces, since the two have the same restrictions, i.e. they can only be used
as type parameter bounds.

\subsection{Comparison with existing proposal}

Shortly after the Type Parameters proposal was published
\autocite{genericsProposal}, a proposal to extend generics to array sizes was
published \autocite{goArrayProposal}. It would allow type set interfaces of the
following form:

\golisting{./examples/werner/array_interface.go}

In this design, the parameterisation of the array size in implicit using
\texttt{...}, and does not appear in the list of type parameters, meaning the
numerical type parameter cannot be referenced directly. Instead, the proposal
author suggests applying the feature as follows:

\golisting{./examples/werner/matrix.go}

The example can in fact be simplified slightly, by inlining the type set
directly in into the type parameter constraint (allowed as of Go 1.18):

\golisting{./examples/werner/matrix_inline.go}

It could then be instantiated as follows:

\golisting{./examples/werner/matrix_variable.go}

Compare this with the proposal presented in this work. Using the \kw{const}
interface, the analogous code would be as follows:

\golisting{./examples/werner/my_matrix.go}

This approach mandates much less boilerplate than the current proposal, as the
type user is not forced to create ``dummy'' type arguments, and the type author
is not forced to retrieve an implicit numerical parameter through the
\texttt{len} function. Explicit numerical type parameters would make generic
arrays a first-class feature of Go, consistent with the rest of the language.
All the existing compound data types in Go can already be fully type
parameterised (slices: \texttt{[]T}, maps: \texttt{map[K]V} and channels:
\texttt{chan T}), except for arrays, so this work would bridge that gap
(\texttt{[N]T}), without making the feature feel like a workaround. In addition,
explicit numerical type parameters make the code more readable, as the
programmer can immediately see when a type is parameterised on integers.

Not only would arrays become first class, but so would numerical type
parameters. Currently, arrays are the only type which accept a numerical type
parameter, to parameterize the length of an array type. The \kw{const} interface
would allow any type or function to accept a constant integer (or another
\kw{const} bounded type parameter) as a type argument.

The benefit of Werner's proposal, is that is uses existing syntax:
\texttt{[...]T} can already be used to denote an array's type when constructing
an array literal:

\golisting{./examples/werner/array_literal.go}

where \texttt{myArray} has an inferred type of \texttt{[3]int}. It's worth
noting however, that this syntax is used for type inference, as opposed to
denote the type of a value, similar to how in some cases type arguments can be
omitted, where the compiler is able to infer what they are.

% TODO describe pros and cons of existing proposal
% cons: 
%       difficulty of implementing type arguments using expressions (e.g. len([...]T) + 1)


\subsubsection{The \texttt{len} function}

Go's built-in \texttt{len} function is special in the sense that depending on
the context, it may or may not be computed at compile time \autocite{spec}. If
it is computed at compile time, we can assign the result to a \kw{const}
variable, or use it in any other place that requires a compile-time constant
non-negative integer value, such as for the length of an array.

An example of a compile-time evaluation of \texttt{len} is when it is applied to
an array value literal, and an example of a run-time evaluation of \texttt{len}
is when it is applied to a slice value. The question arises, how should
\texttt{len} treat generic arrays (specifically, ones that are parameterised on
size)?

Interestingly, there are already cases, where a value of array type does not
have compile-time \texttt{len} semantics. In particular, the spec says
\texttt{len} does not yield a constant for array type expressions that ``contain
channel receives or (non-constant) function calls'' \autocite{spec}. While this
is indeed the case as of Go 1.21, assigning the result of such a
``non-constant'' expression to a variable, and then calling \texttt{len} on that
variable, \emph{does} yield a constant. As such, this restriction appears to be
a compiler limitation, as opposed to being inherent to the language.

If we take Rust's approach of prohibiting the use of expressions that include
constant type parameters (except when the expression is a lone type parameter)
as type arguments, which include applying \texttt{len} to a generically sized
array, then it becomes clear why \texttt{len} of a generically sized array
should yield a non-constant integer (as indeed is the case in Rust). Without
this restriction, the compiler would have to keep track of which constant was
derived from an expression containing a type-parameter, to prevent the later
usage of such a constant (or another const expression containing it) as a type
argument.

If we permit non-trivial constant expressions containing type parameters as type
arguments, then the model is sound when \texttt{len} evaluates to a constant. As
a side remark, why would we need to even call \texttt{len} on a generically
sized array, since the numerical type parameter used to size it is in scope? The
same could be asked for the existing semantics of \texttt{len} on arrays: why
call \texttt{len} if the array size could be made a constant, and referenced in
multiple places? One justification comes to mind: when dealing with multiple
arrays of various sizes, it may be easier to use the wrong type parameter (or
constant in the non-generic case) than we intend to, whereas calling
\texttt{len} is guaranteed to yield the actual length of the array.

% TODO think of a scenario of using len as opposed to the type parameter?

% TODO why is len of a generic array not a constant in Rust?
% probably because it cannot be used as a type parameter

\subsubsection{Allowed \texttt{const} type arguments}

% Maybe we allow complex expressions for non-recursive structures? Go already
% does recursion detection in the compiler

% Evaluate both conservative (Rust) and permissive (Werner) approaches

\subsubsection{Community concerns}
