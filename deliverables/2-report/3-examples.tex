\section{Arrays by Example}

Most of the time, Go programmers will use slices over arrays due to their
dynamic nature. However, when the size of a collection of elements can be
determined at compile time, there are certain benefits to using arrays. This
section intends to identify use cases where using arrays in Go programs may be
more beneficial than using slices, and what are the benefits and the performance
implications.

A major drawback.

\subsection{Gentle introduction}

The first function we'll examine is one that creates a reversed copy of an
array/slice. Below is a side-by-side view of the two functions: the first
operating on arrays, and the second operating on slices.

\noindent\begin{minipage}{\linewidth}
    \lstinputlisting[language=Go, tabsize=4, firstline=3]{../../projects/go-generic-array-sizes/benchmarks/benchmarks/reversed/arrays.go}
\end{minipage}

\noindent\begin{minipage}{\linewidth}
    \lstinputlisting[language=Go, tabsize=4, firstline=3]{../../projects/go-generic-array-sizes/benchmarks/benchmarks/reversed/slices.go}
\end{minipage}

The slice function is almost identical to the array function, except that we
need to explicitly allocate a new slice for the result. Arrays are value types,
so simply passing an array into a function (and similarly returning an array
from a function) creates a copy. For relatively small arrays (8MB in size or
less), the memory for the array copy is allocated on the stack. For slices
however, even for the smallest slices (of length 1 or more), the
\texttt{reversed} function allocates the new slice on the heap. This operation
is more expensive, and so, as the benchmarks show, the array variant of the
\texttt{reversed} functions performs on average around 50\% faster for arrays of
size 8MB or less. For very small arrays (64 \texttt{int}s or less), the
performance benefits or arrays for this operation are even more apparent. Once
the array reaches 16MB or more, the memory for the copy gets allocated onto the
heap, and in fact becomes slower than using slices. The benchmarks are limited
to 256MB, since at array sizes of 512MB the compiler rejects the program, since
it could potentially use up more than 1GB of stack space (we need to multiply
512MB by two since we are creating a copy of the array). So if collections of
such large sizes are necessary, slices are the only option. For smaller sizes,
however, arrays perform better.

The benchmarks were run on a single core, using \texttt{GOMAXPROCS=1}, and the
results of the functions were written to global variables, in an attempt to
prevent the compiler from eliminating the benchmarked code \autocite{benchPits}.

\begin{figure}
    \input{../../projects/go-generic-array-sizes/benchmarks/runner/outputs/reversed/ArraySlice/reversed}
    \caption{Comparison of \texttt{reversed} function benchmarks captured on
        Apple M1 Pro}
\end{figure}

The literal \texttt{N} in the array type refers to a constant, defined elsewhere
in the program. The function signature only accepts arrays of size \texttt{N},
despite the function body being generic enough that it could work on arrays of
any size. To illustrate the point, the next example will inline \texttt{N} with
an integer literal. The function also happens to only accept \texttt{int}
arrays, but this can easily be fixed using generic type parameters, introduced
in Go 1.18 (unfortunately, at the cost of some performance):

% TODO consider placing complete benchmarks in appendix

\noindent\begin{minipage}{\linewidth}
    \lstinputlisting[language=Go, tabsize=4, firstline=3]{./examples/reversed/generic_type.go}
\end{minipage}

The implication of this is that for each different array size we want
to use the \texttt{reversed} operation on, we would have to write a new function
with the exact same code, or use a code generation tool to do this for us.

As of Go 1.18, there is a workaround that partially solves the above problem.
Interface types are now defined in terms of the more general notion of type
sets, as opposed to method sets pre Go 1.18 \autocites{spec}{specPre1.18}.
"General interfaces" were introduced, that can only be (as of Go 1.21) used as
type parameter constraints, and among its features is the ability to specify a
union of types. With this, we can define an interface in terms of the union of
differently sized array that we wish to use with our \texttt{reversed} function
\autocite{goArrayProposal}:

\noindent\begin{minipage}{\linewidth}
    \lstinputlisting[language=Go, tabsize=4, firstline=3]{./examples/reversed/union_type.go}
\end{minipage}

This approach still has limitations. Apart from the obvious burden of having to
update the \texttt{array} interface every time we use an array of a new size,
this model breaks down as soon as we wish to expose such a function as part of a
public API. There is no way of knowing ahead of time what array sizes a user may
wish to use, and enumerating them all is infeasible. Ideally we'd want a way to
abstract over arrays of any size.

% Subsection 1: Gentle introduction

% Example 1: `reversed` function

% Show current workaround with "union-like" interfaces and discuss its
% limitations

% Subsection 2: Data-structure examples

% Example 2: Array struct with static capacity and len field

% Example 3: Ring buffer of static size

% Subsection 3: Operation examples

% Example 4: Usage of arrays and above data structures as map keys

% Example 5: Comparison of deeply nested structure possible with array, but not
% slices

% Example 6: Trivial deep-copies (via assignment/dereferencing) of deeply nested
% structures with arrays

% Subsection 4: Real-world use-case examples

% Any other examples from current issue and proposal

% Subsection 5: Benchmarks

% Benchmarks of all examples comparing arrays with slices, both using pointers
% to and copies of arrays, both large and small array sizes. Use escape analysis
% to see where arrays/slices are being allocated to.

% State machine used in benchmarks (potentially benchmark on amd64 as well as
% arm64)

% Subsection 6: Type-set interfaces and the \kw{const} interface

% conceptually: type const interface { 0 | 1 | 2 | 3 | ... }
% implementation: type const interface { const }, analogous to comparable interface

% TODO compare with existing proposal

% TODO explain in FGGA why const is not an interface - because FGGA only
% considers classic interfaces, not type-set interfaces, introduced in the type
% parameter proposal. Type-set interfaces have same restrictions as \kw{const},
% i.e. they can only be used as type parameter bounds
