\section{Introduction}

Generics have been introduced in the Go programming language following the
theoretical work by \cite{fg} in \emph{Featherweight Go}. The \emph{Type
    Parameters Proposal} lists several generic programming constructs not supported
by the initial implementation of generics (as of Go 1.18). Among them is ``no
parameterization on non-type values such as constants.''
\autocite{genericsProposal} The most notable use case of such type parameters
would be for arrays. In Go, the size of an array is part of its type
\autocite{spec}. As such, if the programmer wishes to write a function that
operates on arrays or a data type that contains arrays, it is necessary to
hard-code the size of the operated/contained array. This imposes a limitation on
what abstraction may be introduced where arrays are concerned. Extending the
generic type system in Go to support constants as type parameters aims to
resolve this issue.

\subsection{Background}

Arrays are a primitive data structure found in many programming languages.
However, various languages treat arrays differently. In Java, arrays are
objects, and variables of array type are references to those objects. The size
(or length) of an array is not part of its type, however it is a property of the
array object instance and cannot be changed after initialisation of the instance
\autocite{javaSpec}. C\# treats arrays analogously \autocite{cSharpArrays}. In
languages like Go and Rust, arrays are value types and the size of the array
\emph{is} part is of its type \autocites{spec}{rustSpec}. In C, the size of an
array is also part of its type, however, expressions of array type are converted
to pointers to the first element of the array \autocite{cSpec}. Since
dynamically typed languages do not have types associated with variables, we will
not discuss those languages here.

% TODO talk about first-class vs non first-class arrays, static and only dynamic
% arrays, and whether the size is part of the arrays type or not, and which
% languages are similar to what Go does. Mention that Go has slices for most
% practical use cases. Mention however, the use cases where arrays can come
% handy in Go.

% TODO explain how this problem is tackled in other languages

% C: Arrays are just pointers to the first element (no abstraction)
% "The C programming language"; https://stefansf.de/post/arrays-are-second-class-citizens/
% Python, Ruby, JS: Only dynamic arrays - abstraction on language level
% Java: Array size is static, but not part of its type
% Go, Rust (+ other langs??): Array size is part of type

\subsection{Problem Statement}

% TODO something along the lines of "How can the type system be extended
% to support generically sized arrays in an efficient way, compatible with the
% existing implementation of generics in Go.

\subsection{Aim}

% TODO this will be a formal rules for arrays, their generic counterparts,
% based on Featherweight Go.

\subsection{Objectives}

% Individual deliverable - formal rules + verifying design with interpreter +
% monomorphiser

\subsection{Research Questions}

How have other languages where the size of an array is part of its type tackled
this issue, if at all?

\subsection{Report Structure}

The second chapter explores how other languages have tackled the problem of
abstracting over arrays of any size, as well as past research in the area of
programming languages, in particular relating to the Go programming language.
The third chapter presents a rationale for introducing generically sized arrays
in Go through examples. Chapter four introduces the formal rules for
``Featherweight Go'' --- a subset of Go containing arrays, based on the paper
going by the same name \autocite{fg}. Chapter five extends the rules with
generics as found in today's version of Go and the proposed design for
generically sized arrays. Finally, the sixth chapter gives an overview of the
implementation of two interpreters, each corresponding to the rules found in
chapters four and five.
