\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{mathpartir}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{listings}

\input{../../projects/go-generic-array-sizes/theory/macros}

\title{Summary of Go cycle detection rules}
\author{Dawid Lachowicz}

\begin{document}

\maketitle

\section{Syntax}

\begin{minipage}[t]{\textwidth}
    \begin{tabular}[t]{ll}
        Type                   & $\tau, \sigma$ ::=                                        \\
        \quad Type parameter   & \quad $\alpha$                                            \\
        \quad Named type       & \quad $t[\ov{\tau}]$                                      \\\\
        Type Literal           & $T$ ::=                                                   \\
        \quad Structure        & \quad $\struct~\br{\ov{f~\tau}}$                          \\
        \quad Interface        & \quad $\interface~\br{\ov{S}}$                            \\
        \quad Array            & \quad$[n]\tau$                                            \\
        \\
        Declaration            & $D$ ::=                                                   \\
        \quad Type declaration & \quad $\type~t[\ov{\Phi}]~T$                              \\
        \\
        Program                & $P$ ::= $\package~\main;~\ov{D}~\func~\main()~\br{\un=e}$
    \end{tabular}
\end{minipage}
\hspace{-0.5\textwidth}
\begin{minipage}[t]{0.4\textwidth}
    \begin{tabular}[t]{ll}
        Type name         & $t, u$                                       \\
        Type parameter                                                   \\
        declaration       & $\Phi$ ::= $\alpha~\gamma$                   \\
        Type constraint   & $\gamma$ ::= $t[\ov{\tau}]$                  \\
        \\
        Method signature  & $M$ ::= $(\ov{x~\black{\tau}})~\black{\tau}$ \\
        Interface element & $S$ ::= $mM$                                 \\
        \\
        Field name        & $f$                                          \\
        Method name       & $m$                                          \\
        Variable          & $x$
    \end{tabular}
\end{minipage}

\section{Typing rules}

\noindent Well-formed declarations \hfill \fbox{$D \ok$}
\begin{mathpar}
    \inferrule[t-type]
    {
    \ov{\Phi \ok}
    \\
    \ov{\Phi} \vdash~T \ok
    \\
    \notcont(t,~T)
    }
    { \type~t[\ov{\Phi}]~T \ok }
\end{mathpar}

\noindent Programs  \hfill \fbox{$P \ok$}
\begin{mathpar}
    \inferrule[t-prog]
    {
        \distinct(\tdecls(\ov{D}), \kw{int}) \\
        \distinct(\mdecls(\ov{D})) \\
        \ov{D \ok} \\
        \black{\emptyset \stoup}~\emptyset \vdash e : \black{\tau}
    }
    { \package~\main;~\ov{D}~\func~\main()~\br{\un=e} \ok }
\end{mathpar}

\section{Cycle detection rules}

\subsection{Type containment rules}

\noindent Type declaration containment \hfill \fbox{$\notcont(\ov{t}, T)$}
\begin{mathpar}
    \inferrule
    {~}
    {
        \notcont(\ov{t_r},~\interface~\br{\ov{S}})
    }
    \\
    \inferrule
    {
        \notcont(\ov{t_r}, \tau)
    }
    {
        \notcont(\ov{t_r},~[n]\tau)
    }

    \inferrule
    {
        \forall \tau \in \ov{f~\tau}.\notcont(\ov{t_r}, \tau)
    }
    {
        \notcont(\ov{t_r},~\struct \br{\ov{f~\tau}})
    }
\end{mathpar}

\noindent Type declaration containment recursion \hfill \fbox{$\notcont(\ov{t}, \tau)$}
\begin{mathpar}
    \inferrule
    {~}
    {
        \notcont(\ov{t_r}, \kw{int})
    }

    \inferrule
    {~}
    {
        \notcont(\ov{t_r}, \alpha)
    }

    \inferrule
    {
    (\type~t[\ov{\Phi}]~T) \in \ov{D}
    \\
    t \notin \ov{t_r}
    \\
    \eta = (\ov{\Phi \by \tau})
    \\
    \notcont(\ov{t_r}, t, T \llbracket\eta\rrbracket)
    }
    {
    \notcont(\ov{t_r}, t[\ov{\tau}])
    }
\end{mathpar}

\begin{itemize}
    \item Type containment checks can be thought of as one phase of the type
          declaration cycle detection, checking the structure of type literals,
          applicable to both generic and non-generic code.

    \item The $\notcont$ relation can be explained as ``asserting a type/type
          literal doesn't contain any of the \emph{already seen} types where they are
          not allowed to occur in the type's structure''.

    \item As recursion progresses, the encountered type names $t$ are added to
          the set of already seen type names ($\notcont(\ov{t_r}, t, T
              \llbracket\eta\rrbracket)$). This is so we can detect indirect cycles
          without getting the algorithm into an infinite loop.

    \item Basic interfaces (and other pointer types) can refer to the type being
          defined in their structure, and therefore are base cases of the
          recursion.

    \item $\notcont(\ov{t_r}, \kw{int})$ can be more widely applied to primitive
          (predeclared) types in Go. Since primitive types may be redefined in a Go
          program, we'd need to check whether a type name (e.g. $\kw{int}$) indeed
          still points at a primitive type.

    \item Type parameters shadow type names. Whenever a type parameter is
          encountered during the containment check, a base case of the recursion is
          reached.

    \item The $T \llbracket\eta\rrbracket$ notation indicates that the type
          literal has its type parameters $\alpha$ substituted with type arguments
          $\tau$.

    \item Note in particular, that these rules do not recurse on type parameter
          constraints of the checked types.
          \href{https://github.com/golang/go/issues/65714}{Issue \#65714}
          demonstrates a family of programs where the type checker sometimes
          rejects programs based on cycles mixing containment rules and type
          parameter constraint reference rules (described in the next section),
          depending on the ordering of type declarations.
\end{itemize}

% TODO mention that non-basic interfaces (e.g. embedded or type set interfaces)
% need to be checked for containment cycles

\subsection{Lifting type parameter reference rules}

\begin{itemize}
    \item The Go spec currently states: ``Within a type parameter list of a
          generic type T, a type constraint may not (directly, or indirectly
          through the type parameter list of another generic type) refer to T.''
          We can in fact life this restriction, i.e. allowing type parameter
          constraints to refer to the type T being defined.
\end{itemize}

\section{Examples}

\subsection{Containment check in generic type}

\noindent\begin{minipage}[t]{.45\linewidth}
    \lstinputlisting[language=Go, tabsize=4, firstline=3]
    {./examples/generic-containment-any.go}

    The definition of \texttt{Bar} should be rejected, since it creates a type
    containment cycle via \texttt{Foo}. The compiler correctly reports \texttt{Bar}
    as an invalid recursive type.
\end{minipage}
\hfill
\noindent\begin{minipage}[t]{.45\linewidth}
    \lstinputlisting[language=Go, tabsize=4, firstline=3, lastline=35]
    {./examples/generic-containment-clean.go}

    Using e.g. a pointer to \texttt{T} in the
    definition of \texttt{Foo} would make the program valid. We can even
    change the type constraint of \texttt{T} from \texttt{any} to \texttt{Bar}, and
    the type checker should behave the same. However, as of Go 1.23, such a program
    is either rejected or accepted by the type checker depending on the order of the
    struct declarations (similar to \href{https://github.com/golang/go/issues/65714}{Issue
        \#65714}).

\end{minipage}

\subsubsection{Type checking derivation with contradiction}

Below, we derive a contradiction while type checking the above program on the
left, showing that the $\notcont$ rule is sufficient for detecting structural
cycles in generic types.

\input{generic-containment-any}

\subsection{Issue \#51244}

\href{https://github.com/golang/go/issues/51244}{Issue \#51244} demonstrates
another case where the compiler's cycle detection accepts or rejects the program
depending on the order of type declarations. According to the above defined
rules, the program should be accepted. One of the participants of the issue
(\href{https://github.com/findleyr}{findleyr}) also suggested removing the
restriction of cycles through type parameter constraints.

\subsubsection{Accepting type checking derivation}

\golisting{./examples/issue-51244.go}

\noindent
Below is a derivation of the program in the issue, with minor adjustments to
fit a Featherweight Go-like syntax used in this document.

\input{issue-51244}

% TODO appendix will define remaining rules that have been referenced in rules
% or derivations

\subsection{Self-referential type parameter constraints}

% TODO some writeup about how Featherweight Generic Go allowed self-referential
% type parameter constraints, but the current Go spec and compiler disallow
% this.

\subsubsection{Negative example}

\golisting{./examples/self-ref-invalid.go}

\input{self-ref-invalid}

\subsubsection{Positive example}

\golisting{./examples/self-ref-valid.go}

\input{self-ref-valid}

% TODO mention Go's structural subtyping

\end{document}
