\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{mathpartir}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{xcolor}
\usepackage{hyperref}

\input{../../projects/go-generic-array-sizes/theory/macros}

\title{Summary of Go cycle detection rules}
\author{Dawid Lachowicz}

\begin{document}

\maketitle

\section{Syntax}

\begin{minipage}[t]{\textwidth}
    \begin{tabular}[t]{ll}
        Type                   & $\tau, \sigma$ ::=                                        \\
        \quad Type parameter   & \quad $\alpha$                                            \\
        \quad Named type       & \quad $t[\ov{\tau}]$                                      \\
        \quad Anonymous type   & \quad $T$                                                 \\\\
        Type Literal           & $T$ ::=                                                   \\
        \quad Structure        & \quad $\struct~\br{\ov{f~\tau}}$                          \\
        \quad Interface        & \quad $\interface~\br{\ov{S}}$                            \\
        \quad Array            & \quad$[n]\tau$                                            \\
        \\
        Declaration            & $D$ ::=                                                   \\
        \quad Type declaration & \quad $\type~t[\ov{\Phi}]~T$                              \\
        \\
        Program                & $P$ ::= $\package~\main;~\ov{D}~\func~\main()~\br{\un=e}$
    \end{tabular}
\end{minipage}
\hspace{-0.5\textwidth}
\begin{minipage}[t]{0.4\textwidth}
    \begin{tabular}[t]{ll}
        Type name         & $t, u$                                       \\
        Type parameter                                                   \\
        declaration       & $\Phi$ ::= $\alpha~\gamma$                   \\
        Type constraint   & $\gamma$ ::= $t[\ov{\tau}] \mid T$           \\
        \\
        Method signature  & $M$ ::= $(\ov{x~\black{\tau}})~\black{\tau}$ \\
        Type union        & $U$ ::= $\ov{\gamma}$                        \\
        Interface element & $S$ ::= $mM \mid U$                          \\
        \\
        Field name        & $f$                                          \\
        Method name       & $m$                                          \\
        Variable          & $x$
    \end{tabular}
\end{minipage}

\section{Typing rules}

\noindent Well-formed declarations \hfill \fbox{$D \ok$}
\begin{mathpar}
    \inferrule[t-type]
    {
    \ov{\Phi \ok}
    \\
    \ov{\Phi} = (\ov{\alpha~\gamma})
    \\
    \ov{\notref_\alpha(t, \gamma)}
    \\
    \ov{\Phi} \vdash~T \ok
    \\
    \notcont(t,~T)
    }
    { \type~t[\ov{\Phi}]~T \ok }
\end{mathpar}

\noindent Programs  \hfill \fbox{$P \ok$}
\begin{mathpar}
    \inferrule[t-prog]
    {
        \distinct(\tdecls(\ov{D}), \kw{int}) \\
        \distinct(\mdecls(\ov{D})) \\
        \ov{D \ok} \\
        \black{\emptyset \stoup}~\emptyset \vdash e : \black{\tau}
    }
    { \package~\main;~\ov{D}~\func~\main()~\br{\un=e} \ok }
\end{mathpar}

\section{Cycle detection rules}

\subsection{Type containment rules}

\noindent Type declaration containment \hfill \fbox{$\notcont(\ov{t}, T)$}
\begin{mathpar}
    \inferrule
    {
        \forall S \in \ov{S}.\notcont(\ov{t_r}, S)
    }
    {
        \notcont(\ov{t_r},~\interface~\br{\ov{S}})
    }
    \\
    \inferrule
    {
        \notcont(\ov{t_r}, t)
    }
    {
        \notcont(\ov{t_r},~[n]t)
    }

    \inferrule
    {
        \forall t \in \ov{f~t}.\notcont(\ov{t_r}, t)
    }
    {
        \notcont(\ov{t_r},~\struct \br{\ov{f~t}})
    }
\end{mathpar}

\noindent Interface element containment \hfill \fbox{$\notcont(\ov{t}, S)$}

\begin{mathpar}
    \inferrule
    {~}
    {
        \notcont(\ov{t_r}, mM)
    }

    \inferrule
    {
        \forall \tau \in \ov{\tau}.\notcont(\ov{t_r},\gamma)
    }
    {
        \notcont(\ov{t_r}, \ov{\gamma})
    }
\end{mathpar}

\noindent Type declaration containment recursion \hfill \fbox{$\notcont(\ov{t}, \tau)$}
\begin{mathpar}
    \inferrule
    {~}
    {
        \notcont(\ov{t_r}, \kw{int})
    }

    \inferrule
    {~}
    {
        \notcont(\ov{t_r}, \alpha)
    }

    \inferrule
    {
    (\type~t[\ov{\Phi}]~T) \in \ov{D}
    \\
    t \notin \ov{t_r}
    \\
    \eta = (\ov{\Phi \by \tau})
    \\
    \notcont(\ov{t_r}, t, T \llbracket\eta\rrbracket)
    }
    {
    \notcont(\ov{t_r}, t[\ov{\tau}])
    }
\end{mathpar}

\begin{itemize}
    \item Type containment checks can be thought of as one phase of the type
          declaration cycle detection, checking the structure of type literals,
          applicable to both generic and non-generic code.

    \item The $\notcont$ relation can be explained as ``asserting a type/type
          literal doesn't contain any of the \emph{already seen} types where they are
          not allowed to occur in the type's structure''.

    \item As recursion progresses, the encountered type names $t$ are added to
          the set of already seen type names ($\notcont(\ov{t_r}, t, T
              \llbracket\eta\rrbracket)$). This is so we can detect indirect cycles
          without getting the algorithm into an infinite loop.

    \item Basic interfaces (and other pointer types) can refer to themselves, and
          therefore are base cases of the recursion. Type sets (unions) in
          general interfaces on the other hand are checked for cycles.

    \item $\notcont(\ov{t_r}, \kw{int})$ can be more widely applied to primitive
          (predeclared) types in Go. Since primitive types may be redefined in a Go
          program, we'd need to check whether a type name (e.g. $\kw{int}$) indeed
          still points at a primitive type.

    \item Type parameters shadow type names. Whenever a type parameter is
          encountered during the containment check, a base case of the recursion is
          reached.

    \item The $T \llbracket\eta\rrbracket$ notation indicates that the type
          literal has its type parameters $\alpha$ substituted with type arguments
          $\tau$.

    \item Anonymous types, when by themselves, are free from cycles by their
          very nature of being anonymous. However, they may form a part of a
          cycle when embedded into another type.

    \item Note in particular, that these rules do not recurse on type parameter
          constraints of the checked types.
          \href{https://github.com/golang/go/issues/65714}{Issue \#65714}
          demonstrates a family of programs where the type checker sometimes
          rejects programs based on cycles mixing containment rules and type
          parameter constraint reference rules (described in the next section),
          depending on the ordering of type declarations.
\end{itemize}

\subsection{Type parameter reference rules}

\noindent Type parameter constraint reference \hfill \fbox{$\notref_\alpha(\ov{t}, \tau)$}
\begin{mathpar}
    \axiomrule{
        \notref_\alpha(\ov{t_r},~\alpha)
    }

    \inferrule
    {
        \ov{\notref_\alpha(\ov{t_r},~\tau)}
        \\
        t \notin \ov{t_r}
        \\
        (\ov{\alpha~\gamma}) = \typeparams(t)
        \\
        \ov{
            \notref_\alpha(\ov{t_r}, t, \gamma)
        }
    }
    {
        \notref_\alpha(\ov{t_r},~t[\ov{\tau}])
    }
\end{mathpar}

\begin{itemize}
    \item Type parameter constraint reference checks can be thought of as
          another phase of type declaration cycle detection, checking the structure of
          type parameter lists, applicable to generic code only.
    \item The $\notref_\alpha$ relation can be explained as ``asserting a type
          constraint doesn't contain any of the \emph{already seen} types''. It
          aims to capture the following part of the spec: ``Within a type
          parameter list of a generic type T, a type constraint may not
          (directly, or indirectly through the type parameter list of another
          generic type) refer to T.''
    \item When checking a named type constraint, we must recursively check its
          type arguments, and recursively check the bounds of the type parameter
          list of the named type, adding that named type to the set of already
          seen types in the latter case (again, for indirect cycle detection).
    \item The base case of the recursion is encountering a non-generic named
          type (there will be no type arguments or constraints to recurse on),
          or encountering a type parameter, which is always okay to have within
          the structure of a type constraint (i.e. in type parameter list or
          type literal).
    \item Once again, type parameters shadow declared types in the type
          parameter list.
    \item IDEs like JetBrains GoLand struggle with these rules in particular,
          e.g. failing to report a cycle (false negative), or failing to
          recognise that a type parameter has shadowed a generic type, raising
          an error (false positive).
\end{itemize}

\subsection{Anonymous type parameter constraints}

\begin{mathpar}

\end{mathpar}

\noindent Anonymous type parameter constraint reference \hfill
\fbox{$\notref_\alpha(\ov{t}, T)$}

\begin{mathpar}
    \inferrule
    {
        \forall S \in \ov{S}.\notref_\alpha(\ov{t_r}, S)
    }
    {
        \notref_\alpha(\ov{t_r},~\interface~\br{\ov{S}})
    }
    \\
    \inferrule
    {
        \notref_\alpha(\ov{t_r}, t)
    }
    {
        \notref_\alpha(\ov{t_r},~[n]t)
    }

    \inferrule
    {
        \forall t \in \ov{f~t}.\notref_\alpha(\ov{t_r}, t)
    }
    {
        \notref_\alpha(\ov{t_r},~\struct \br{\ov{f~t}})
    }
\end{mathpar}

\noindent Method specification reference \hfill
\fbox{$\notref_\alpha(\ov{t}, S)$}

\begin{mathpar}
    \inferrule
    {
        \ov{\notref_\alpha(\ov{t_r}, \tau)} \\
        \notref_\alpha(\ov{t_r}, \tau)
    }
    {
        \notref_\alpha(\ov{t}, m(\ov{x~\black{\tau}})~\black{\tau})
    }

    \inferrule
    {
        \forall \tau \in \ov{\tau}.\notref_\alpha(\ov{t_r},\gamma)
    }
    {
        \notref_\alpha(\ov{t_r}, \ov{\gamma})
    }
\end{mathpar}

\begin{itemize}
    \item When anonymous types are used as type parameter constraints, they may
          not reference the type being defined anywhere in their structure. This
          also applies interface types this time (and any pointer types in
          general).
    \item Additionally, any named type in the structure of anonymous types
          constraints have their type parameter constraints recursively checked
          for cycles.
    \item Anonymous types may be nested --- the same recursive rules apply.
\end{itemize}

\end{document}
