@book{tapl,
  author    = {Pierce, Benjamin C.},
  title     = {Types and Programming Languages},
  year      = {2002},
  isbn      = {0262162091},
  publisher = {The MIT Press},
  edition   = {1},
  abstract  = {A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute. The study of type systems -- and of programming languages from a type-theoretic perspective -- has important applications in software engineering, language design, high-performance compilers, and security.This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations. Each chapter is accompanied by numerous exercises and solutions, as well as a running implementation, available via the Web. Dependencies between chapters are explicitly identified, allowing readers to choose a variety of paths through the material.The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators. Extended case studies develop a variety of approaches to modeling the features of object-oriented languages.}
}
@article{fg,
  author     = {Griesemer, Robert and Hu, Raymond and Kokke, Wen and Lange, Julien and Taylor, Ian Lance and Toninho, Bernardo and Wadler, Philip and Yoshida, Nobuko},
  title      = {Featherweight {Go}},
  year       = {2020},
  issue_date = {November 2020},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {4},
  number     = {OOPSLA},
  url        = {https://doi.org/10.1145/3428217},
  doi        = {10.1145/3428217},
  abstract   = {We describe a design for generics in Go inspired by previous work on Featherweight Java by Igarashi, Pierce, and Wadler. Whereas subtyping in Java is nominal, in Go it is structural, and whereas generics in Java are defined via erasure, in Go we use monomorphisation. Although monomorphisation is widely used, we are one of the first to formalise it. Our design also supports a solution to The Expression Problem.},
  journal    = {{Proc. ACM Program. Lang.}},
  month      = {11},
  articleno  = {149},
  numpages   = {29},
  keywords   = {Go, Monomorphisation, Generics}
}
@online{rustConstBlog,
  author       = {{The const generics project group}},
  title        = {Const generics {MVP} hits beta!},
  organization = {Rust Blog},
  url          = {https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html},
  year         = {2021},
  month        = {11},
  day          = {26},
  urldate      = {2023-11-12}
}
@online{genericsProposal,
  title        = {Type Parameters Proposal},
  author       = {Taylor, Ian Lance and Griesemer, Robert},
  organization = {Google Open Source},
  url          = {https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md},
  year         = {2021},
  month        = {11},
  day          = {20},
  urldate      = {2023-11-16}
}

@online{contractsProposal,
  title        = {Contracts — Draft Design},
  author       = {Taylor, Ian Lance and Griesemer, Robert},
  organization = {Google Open Source},
  url          = {https://go.googlesource.com/proposal/+/master/design/go2draft-contracts.md},
  year         = {2019},
  month        = {7},
  day          = {31},
  urldate      = {2024-04-24}
}

@online{myProposal,
  title   = {proposal: Go 2: Const generics},
  author  = {Lachowicz, Dawid},
  url     = {https://github.com/golang/go/issues/65555},
  year    = {2024},
  month   = {2},
  day     = {6},
  urldate = {2024-04-24}
}

@online{spec,
  title        = {The {Go} Programming Language Specification},
  organization = {Google Open Source},
  url          = {https://go.dev/ref/spec},
  year         = {2023},
  month        = {8},
  day          = {2},
  urldate      = {2023-11-16}
}

@online{specPre1.18,
  title        = {The {Go} Programming Language Specification},
  organization = {Google Open Source},
  url          = {https://go.dev/doc/go1.17_spec},
  year         = {2021},
  month        = {10},
  day          = {15},
  urldate      = {2024-01-20}
}

@online{javaSpec,
  title        = {The {Java}\textsuperscript{\textregistered} Language Specification},
  author       = {Gosling, James
                  and Joy, Bill
                  and Steele, Guy
                  and Bracha, Gilad
                  and Buckley, Alex
                  and Smith, Daniel
                  and Bierman, Gavin},
  organization = {Oracle},
  edition      = {Java SE 21 Edition},
  url          = {https://docs.oracle.com/javase/specs/jls/se21/html/index.html},
  year         = {2023},
  month        = {08},
  day          = {23},
  urldate      = {2023-11-21}
}

@online{rustSpec,
  title   = {The {Rust} Reference},
  url     = {https://doc.rust-lang.org/stable/reference/},
  year    = {2020},
  month   = {8},
  day     = {3},
  urldate = {2023-11-21}
}

@online{cSharpArrays,
  title        = {C\# reference: Arrays},
  author       = {Wagner, Bill},
  organization = {Microsoft},
  url          = {https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/arrays},
  year         = {2023},
  month        = {9},
  day          = {1},
  urldate      = {2023-11-23}
}

@techreport{cSpec,
  title       = {Programming languages — {C}},
  author      = {ISO/IEC},
  type        = {ISO/IEC},
  number      = {9899:2018},
  institution = {ISO/IEC},
  address     = {Geneva, Switzerland},
  year        = {2018},
  month       = {6},
  edition     = {4}
}

@online{survey2021,
  title        = {{Go} Developer Survey 2021 Results},
  author       = {Merrick, Alice},
  organization = {The {Go} Blog},
  year         = {2022},
  month        = {4},
  day          = {19},
  url          = {https://go.dev/blog/survey2021-results},
  urldate      = {2023-11-24}
}

@online{survey2020,
  title        = {{Go} Developer Survey 2020 Results},
  author       = {Merrick, Alice},
  organization = {The {Go} Blog},
  year         = {2021},
  month        = {3},
  day          = {9},
  url          = {https://go.dev/blog/survey2020-results},
  urldate      = {2023-11-24}
}

@online{survey2019,
  title        = {{Go} Developer Survey 2019 Results},
  author       = {Todd Kulesza},
  organization = {The {Go} Blog},
  year         = {2020},
  month        = {4},
  day          = {20},
  url          = {https://go.dev/blog/survey2019-results},
  urldate      = {2023-11-24}
}

@article{fj,
  author     = {Igarashi, Atshushi and Pierce, Benjamin and Wadler, Philip},
  title      = {Featherweight {Java}: A Minimal Core Calculus for {Java} and {GJ}},
  year       = {1999},
  issue_date = {Oct. 1999},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {34},
  number     = {10},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/320385.320395},
  doi        = {10.1145/320385.320395},
  abstract   = {Several recent studies have introduced lightweight versions of Java: reduced languages in which complex features like threads and reflection are dropped to enable rigorous arguments about key properties such as type safety. We carry this process a step further, omitting almost all features of the full language (including interfaces and even assignment) to obtain a small calculus, Featherweight Java, for which rigorous proofs are not only possible but easy.Featherweight Java bears a similar relation to full Java as the lambda-calculus does to languages such as ML and Haskell. It offers a similar computational “feel,” providing classes, methods, fields, inheritance, and dynamic typecasts, with a semantics closely following Java's. A proof of type safety for Featherweight Java thus illustrates many of the interesting features of a safety proof for the full language, while remaining pleasingly compact. The syntax, type rules, and operational semantics of Featherweight Java fit on one page, making it easier to understand the consequences of extensions and variations.As an illustration of its utility in this regard, we extend Featherweight Java with generic classes in the style of GJ (Bracha, Odersky, Stoutamire, and Wadler) and sketch a proof of type safety. The extended system formalizes for the first time some of the key features of GJ.},
  journal    = {{SIGPLAN Not.}},
  month      = {10},
  pages      = {132-146},
  numpages   = {15},
  keywords   = {language design, implementation, theoretical foundations}
}

@online{generics1.18,
  title        = {Go 1.18 Implementation of Generics via Dictionaries and Gcshape Stenciling},
  author       = {Scales, Dan and Randall, Keith},
  organization = {Google Open Source},
  year         = {2022},
  month        = {2},
  day          = {28},
  url          = {https://go.googlesource.com/proposal/+/refs/heads/master/design/generics-implementation-dictionaries-go1.18.md},
  urldate      = {2023-11-25}
}

@online{rustCompilerGuide,
  title   = {Rust Compiler Development Guide},
  url     = {https://rustc-dev-guide.rust-lang.org/},
  year    = {2023},
  month   = {3},
  day     = {3},
  urldate = {2023-11-25}
}

@online{goSimplicity,
  title   = {Simplicity is Complicated},
  author  = {Pike, Rob},
  year    = {2015},
  month   = {11},
  day     = {9},
  url     = {https://go.dev/talks/2015/simplicity-is-complicated.slide},
  urldate = {2023-11-25}
}

@online{rustConstRFC,
  title   = {Const generics},
  author  = {Aronson, Saoirse},
  url     = {https://rust-lang.github.io/rfcs/2000-const-generics.html},
  year    = {2017},
  month   = {5},
  day     = {1},
  urldate = {2023-11-25}
}

@online{goArrayProposal,
  title        = {Proposal: Generic parameterization of array sizes},
  author       = {Werner, Andrew},
  url          = {https://go.googlesource.com/proposal/+/HEAD/design/44253-generic-array-sizes.md},
  organization = {Google Open Source},
  year         = {2021},
  month        = {3},
  day          = {16},
  urldate      = {2023-11-26}
}

@online{goArraySAT,
  title        = {proposal: Go 2: spec: generic parameterization of array sizes},
  author       = {Wagner, Axel},
  url          = {https://github.com/golang/go/issues/44253#issuecomment-821047754},
  organization = {Google Open Source},
  year         = {2021},
  month        = {4},
  day          = {16},
  urldate      = {2024-01-23}
}

@misc{evalContexts,
  author    = {Myers, Andrew},
  title     = {{CS} 6110 Lecture 8: Evaluation Contexts, Semantics by Translation},
  url       = {https://courses.cs.cornell.edu/cs6110/2009sp/lectures/lec08-sp09.pdf},
  year      = {2009},
  month     = {2},
  day       = {11},
  publisher = {Cornell University},
  urldate   = {2023-11-27}
}

@online{benchPits,
  title   = {How to write benchmarks in {Go}},
  author  = {Dave Cheney},
  url     = {https://eli.thegreenplace.net/2023/common-pitfalls-in-go-benchmarking/},
  year    = {2013},
  month   = {6},
  day     = {30},
  urldate = {2024-01-19}
}

@online{ringBuffer,
  title   = {Creating a Circular Buffer in C and C++},
  author  = {Johnston, Phillip},
  url     = {https://embeddedartistry.com/blog/2017/05/17/creating-a-circular-buffer-in-c-and-c/},
  year    = {2017},
  month   = {5},
  day     = {17},
  urldate = {2024-01-26}
}

@online{deepEqual,
  title   = {{reflect.DeepEqual}  on two empty slices returns false},
  author  = {Joe Tsai},
  url     = {https://github.com/golang/go/issues/42265#issuecomment-718304456},
  year    = {2020},
  month   = {10},
  day     = {29},
  urldate = {2024-01-26}
}

@article{newOldLang,
  author     = {Steele, Guy L.},
  title      = {It's Time for a New Old Language},
  year       = {2017},
  issue_date = {August 2017},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {52},
  number     = {8},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/3155284.3018773},
  doi        = {10.1145/3155284.3018773},
  abstract   = {The most popular programming language in computer science has no compiler or interpreter. Its definition is not written down in any one place. It has changed a lot over the decades, and those changes have introduced ambiguities and inconsistencies. Today, dozens of variations are in use, and its complexity has reached the point where it needs to be re-explained, at least in part, every time it is used. Much effort has been spent in hand-translating between this language and other languages that do have compilers. The language is quite amenable to parallel computation, but this fact has gone unexploited.In this talk we will summarize the history of the language, highlight the variations and some of the problems that have arisen, and propose specific solutions. We suggest that it is high time that this language be given a complete formal specification, and that compilers, IDEs, and proof-checkers be created to support it, so that all the best tools and techniques of our trade may be applied to it also.},
  journal    = {SIGPLAN Not.},
  month      = {1},
  pages      = {1},
  numpages   = {1},
  keywords   = {compilers, programming languages, specifications}
}
@inproceedings{dependentPractical,
  author    = {Xi, Hongwei and Pfenning, Frank},
  title     = {Dependent types in practical programming},
  year      = {1999},
  isbn      = {1581130953},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/292540.292560},
  doi       = {10.1145/292540.292560},
  abstract  = {We present an approach to enriching the type system of ML with a restricted form of dependent types, where type index objects are drawn from a constraint domain C, leading to the DML(C) language schema. This allows specification and inference of significantly more precise type information, facilitating program error detection and compiler optimization. A major complication resulting from introducing dependent types is that pure type inference for the enriched system is no longer possible, but we show that type-checking a sufficiently annotated program in DML(C) can be reduced to constraint satisfaction in the constraint domain C. We exhibit the unobtrusiveness of our approach through practical examples and prove that DML(C) is conservative over ML. The main contribution of the paper lies in our language design, including the formulation of type-checking rules which makes the approach practical. To our knowledge, no previous type system for a general purpose programming language such as ML has combined dependent types with features including datatype declarations, higher-order functions, general recursions, let-polymorphism, mutable references, and exceptions. In addition, we have finished a prototype implementation of DML(C) for an integer constraint domain C, where constraints are linear inequalities (Xi and Pfenning 1998).},
  booktitle = {Proceedings of the 26th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {214-227},
  numpages  = {14},
  location  = {San Antonio, Texas, USA},
  series    = {POPL '99}
}

@article{refinement,
  url     = {http://dx.doi.org/10.1561/2500000032},
  year    = {2021},
  volume  = {6},
  journal = {Foundations and Trends® in Programming Languages},
  title   = {Refinement Types: A Tutorial},
  doi     = {10.1561/2500000032},
  issn    = {2325-1107},
  number  = {3-4},
  pages   = {159-317},
  author  = {Ranjit Jhala and Niki Vazou}
}

@inbook{dependentAtWork,
  author    = {Bove, Ana
               and Dybjer, Peter},
  editor    = {Bove, Ana
               and Barbosa, Lu{\'i}s Soares
               and Pardo, Alberto
               and Pinto, Jorge Sousa},
  title     = {Dependent Types at Work},
  booktitle = {Language Engineering and Rigorous Software Development: International LerNet ALFA Summer School 2008, Piriapolis, Uruguay, February 24 - March 1, 2008, Revised Tutorial Lectures},
  year      = {2009},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {57--99},
  abstract  = {In these lecture notes we give an introduction to functional programming with dependent types. We use the dependently typed programming language Agda which is an extension of Martin-L{\"o}f type theory. First we show how to do simply typed functional programming in the style of Haskell and ML. Some differences between Agda's type system and the Hindley-Milner type system of Haskell and ML are also discussed. Then we show how to use dependent types for programming and we explain the basic ideas behind type-checking dependent types. We go on to explain the Curry-Howard identification of propositions and types. This is what makes Agda a programming logic and not only a programming language. According to Curry-Howard, we identify programs and proofs, something which is possible only by requiring that all program terminate. However, at the end of these notes we present a method for encoding partial and general recursive functions as total functions using dependent types.},
  isbn      = {978-3-642-03153-3},
  doi       = {10.1007/978-3-642-03153-3_2},
  url       = {https://doi.org/10.1007/978-3-642-03153-3_2}
}

@online{liquidTypesBlog,
  author       = {Niki Vazou},
  title        = {A Gentle Introduction to Liquid Types},
  organization = {University of California San Diego},
  url          = {https://goto.ucsd.edu/~ucsdpl-blog/liquidtypes/2015/09/19/liquid-types/},
  year         = {2015},
  month        = {9},
  day          = {19},
  urldate      = {2024-04-20}
}

@inproceedings{liquidJava,
  author    = {Gamboa, Catarina and Canelas, Paulo and Timperley, Christopher and Fonseca, Alcides},
  title     = {Usability-Oriented Design of Liquid Types for Java},
  year      = {2023},
  isbn      = {9781665457019},
  publisher = {IEEE Press},
  url       = {https://doi.org/10.1109/ICSE48619.2023.00132},
  doi       = {10.1109/ICSE48619.2023.00132},
  abstract  = {Developers want to detect bugs as early in the development lifecycle as possible, as the effort and cost to fix them increases with the incremental development of features. Ultimately, bugs that are only found in production can have catastrophic consequences.Type systems are effective at detecting many classes of bugs during development, often providing immediate feedback both at compile-time and while typing due to editor integration. Unfortunately, more powerful static and dynamic analysis tools do not have the same success due to providing false positives, not being immediate, or not being integrated into the language.Liquid Types extend the language type system with predicates, augmenting the classes of bugs that the compiler or IDE can catch compared to the simpler type systems available in mainstream programming languages. However, previous implementations of Liquid Types have not used human-centered methods for designing or evaluating their extensions. Therefore, this paper investigates how Liquid Types can be integrated into a mainstream programming language, Java, by proposing a new design that aims to lower the barriers to entry and adapts to problems that Java developers commonly encounter at runtime. Following a participatory design methodology, we conducted a developer survey to design the syntax of LiquidJava, our prototype.To evaluate if the added effort to writing Liquid Types in Java would convince users to adopt them, we conducted a user study with 30 Java developers. The results show that LiquidJava helped users detect and fix more bugs and that Liquid Types are easy to interpret and learn with few resources. At the end of the study, all users reported interest in adopting LiquidJava for their projects.},
  booktitle = {Proceedings of the 45th International Conference on Software Engineering},
  pages     = {1520-1532},
  numpages  = {13},
  keywords  = {liquid types, refinement types, java, usability},
  location  = {Melbourne, Victoria, Australia},
  series    = {ICSE '23}
}

@inproceedings{idris,
  author    = {Brady, Edwin C.},
  title     = {IDRIS ---: systems programming meets full dependent types},
  year      = {2011},
  isbn      = {9781450304870},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1929529.1929536},
  doi       = {10.1145/1929529.1929536},
  abstract  = {Dependent types have emerged in recent years as a promising approach to ensuring program correctness. However, existing dependently typed languages such as Agda and Coq work at a very high level of abstraction, making it difficult to map verified programs to suitably efficient executable code. This is particularly problematic for programs which work with bit level data, e.g. network packet processing, binary file formats or operating system services. Such programs, being fundamental to the operation of computers in general, may stand to benefit significantly from program verification techniques. This paper describes the use of a dependently typed programming language, Idris, for specifying and verifying properties of low-level systems programs, taking network packet processing as an extended example. We give an overview of the distinctive features of Idris which allow it to interact with external systems code, with precise types. Furthermore, we show how to integrate tactic scripts and plugin decision procedures to reduce the burden of proof on application developers. The ideas we present are readily adaptable to languages with related type systems.},
  booktitle = {Proceedings of the 5th ACM Workshop on Programming Languages Meets Program Verification},
  pages     = {43–54},
  numpages  = {12},
  keywords  = {data description, dependent types},
  location  = {Austin, Texas, USA},
  series    = {PLPV '11}
}

@phdthesis{agda,
  author  = {Ulf Norell},
  title   = {Towards a practical programming language based on dependent type
             theory},
  school  = {Department of Computer Science and Engineering, Chalmers University of Technology},
  year    = 2007,
  month   = {9},
  address = {SE-412 96 G\"{o}teborg, Sweden},
  url     = {https://www.cse.chalmers.se/~ulfn/papers/thesis.pdf}
}

@book{lambdaCalculus,
  address   = {New York, N.Y.},
  author    = {Hendrik Pieter Barendregt},
  editor    = {},
  publisher = {Sole distributors for the U.S.A. and Canada, Elsevier Science Pub. Co.},
  title     = {The Lambda Calculus: Its Syntax and Semantics},
  year      = {1981}
}

@article{clrGenerics,
  author     = {Kennedy, Andrew and Syme, Don},
  title      = {Design and implementation of generics for the .NET Common language runtime},
  year       = {2001},
  issue_date = {May 2001},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {36},
  number     = {5},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/381694.378797},
  doi        = {10.1145/381694.378797},
  journal    = {SIGPLAN Not.},
  month      = {5},
  pages      = {1-12},
  numpages   = {12}
}
