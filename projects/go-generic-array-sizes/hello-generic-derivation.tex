\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{ebproof}
\usepackage[left=0.5cm, right=0.5cm]{geometry}

\begin{document}

\include{macros}

\aliasparam{N}
\aliasparam{T}
\register{Array}
\register{any}
\register{this}
\register{First}

\begin{align*}
    D_0       & = \type~\any~\interface\br{}                                                   \\
    D_1       & = \type~\Array[\NParam~\const, \TParam~\any]~[\NParam]\TParam                  \\
    D_2       & = \func (\this~\Array[\NParam, \TParam])~\First()~\any~\br{ \return~\this[0] } \\
    \ov{D}    & = (D_0, D_1, D_2)                                                              \\
    e         & = \Array[2, \kw{int}]\br{1, 2}.\First()                                        \\
    \ov{\Phi} & = (\NParam~\const,\TParam~\any)
\end{align*}

\ws


\begin{prooftree}
    \infer0[T-Interface]{
        \interface\br{} \ok
    }
    \infer1[T-Type]{
        D_0 \ok
    }
\end{prooftree}
\wss

\begin{prooftree}
    \infer0{\distinct(\NParam, \TParam)}
    \infer0[T-Const]{\ov{\Phi} \vdash \const \ok}
    \infer0{D_0 \in \ov{D}}
    \infer1[T-Named]{\ov{\Phi} \vdash \any \ok}
    \infer3[T-Formal]{
        \ov{\Phi} \ok
    }
\end{prooftree}
\wss

\begin{prooftree}
    \infer0{
        (\TParam: \any) \in \ov{\Phi}
    }
    \infer1{
        \methods_{\ov{\Phi}}(\TParam) = \methods_{\ov{\Phi}}(\any)
    }
    \infer1{
        \methods_{\ov{\Phi}}(\TParam) \supseteq \methods_{\ov{\Phi}}(\any)
    }
    \infer0{
        \ov{\Phi} \vdash \TParam \notimp \const
    }
    \infer2[I]{
        \ov{\Phi} \vdash \TParam \imp \any
    }
\end{prooftree}
\wss

\begin{prooftree}
    \hypo{
        \ov{\Phi} \ok
    }
    \infer0{
        (\NParam : \const) \in \ov{\Phi}
    }
    \infer1[Const-Param]{
        \ov{\Phi} \vdash \NParam \imp \const
    }
    \hypo{
        \ov{\Phi} \vdash \TParam \imp \any
    }
    \infer2[T-Array]{
        [\NParam]\TParam \imp \any
    }
    \infer2[T-Type]{
        D_1 \ok
    }
\end{prooftree}
\wss

\begin{prooftree}
    \infer0{
        D_1 \in \ov{D}
    }
    \infer1{
        \ov{\Phi} = \typeparams(\Array)
    }
\end{prooftree}
\wss

\begin{prooftree}
    \hypo{
        \eta_0 = (\NParam \by \NParam, \TParam \by \TParam)
    }
    \infer1{
        \eta_0 = (\NParam~\const \by \NParam, \TParam~\any \by \TParam)
    }
\end{prooftree}
\wss

\begin{prooftree}
    \infer0{
        D_1 \in \ov{D}
    }
    \infer1{
        \TParam = \elementtype(\Array)[\eta_0]
    }
\end{prooftree}
\wss

\begin{prooftree}
    \infer0{
        (\Array[\NParam, \TParam]) \in (\this: \Array[\NParam, \TParam])
    }
    \infer1[T-Var + T-Int-Literal]{
        \ov{\Phi}; \this: \Array[\NParam, \TParam] \vdash
        \this : \Array[\NParam, \TParam],
        0 : \kw{int}
    }
\end{prooftree}
\wss

\begin{prooftree}
    \hypo{
        \begin{matrix}
            \ov{\Phi} = \typeparams(\Array)                                 \\
            \eta_0 = (\NParam~\const \by \NParam, \TParam~\any \by \TParam) \\
            \TParam = \elementtype(\Array)[\eta_0]                          \\
            \ov{\Phi}; \this: \Array[\NParam, \TParam] \vdash
            \this : \Array[\NParam, \TParam],
            0 : \kw{int}
        \end{matrix}
    }
    \infer1[T-Array-Index]{
        \ov{\Phi}; \this: \Array[\NParam, \TParam] \vdash \this[0] : \TParam
    }
\end{prooftree}
\wss

\begin{prooftree}
    \infer0{
        \distinct(\this)
    }
    \infer0{
        D_1 \in \ov{D}
    }
    \infer0{
        (\TParam : \any) \in \ov{\Phi}
    }
    \infer1[T-Param]{
        \ov{\Phi} \vdash \TParam \ok
    }
    \hypo{
        \ov{\Phi}; \this: \Array[\NParam, \TParam] \vdash \this[0] : \TParam
    }
    \infer0[Param]{
        \ov{\Phi} \vdash \TParam \imp \TParam
    }
    \hypo{
        \ov{\Phi} \vdash \TParam \imp \any
    }
    \infer6[T-Func]{
        D_2 \ok
    }
\end{prooftree}
\ws
\begin{prooftree}
    \hypo{
        \eta_1 = (\NParam \by 2,
        \TParam \by \kw{int})
    }
    \infer1{
        \eta_1 = (\NParam~\const \by 2,
        \TParam~\any \by \kw{int})
    }
    \infer0{
        2 \ge 0
    }
    \infer0{
        \methods_{\ov{\Phi}}(\kw{int}) \supseteq \methods_{\ov{\Phi}}(\any)
    }
    \infer0{
        \ov{\Phi} \vdash \kw{int} \notimp \const
    }
    \infer3[Const-N + I]{
        \ov{\Phi} \vdash 2 \imp \const, \kw{int} \imp \any
    }
    \infer2{
        \eta_1 = (\NParam~\const \by_{\ov{\Phi}} 2,
        \TParam~\any \by_{\ov{\Phi}} \kw{int})
    }
\end{prooftree}
\wss

\begin{prooftree}
    \hypo{
        (\First()~\kw{int}) \in \{(First()~\TParam)[\eta_1] \}
    }
    \infer1{
        (\First()~\kw{int}) \in \methods_{\ov{\Phi}}(\Array[2, \kw{int}])
    }
\end{prooftree}
\wss
\begin{prooftree}
    \infer0[T-N-Type + T-Int-Type]{
        \emptyset \vdash 2 \ok, \kw{int} \ok
    }
    \infer0{
        D_1 \in \ov{D}
    }
    \hypo{
        \eta_1
    }
    \infer3[T-Named]{
        \emptyset \vdash \Array[2, \kw{int}] \ok
    }
\end{prooftree}
\wss
\begin{prooftree}
    \infer0{
        D_1 \in \ov{D}
    }
    \infer1{
        \ov{\Phi} = \typeparams(\Array)
    }
\end{prooftree}
\wss
\begin{prooftree}
    \hypo{
        \eta_2 = (\NParam \by 2,
        \TParam \by \kw{int})
    }
    \infer1{
        \eta_2 = (\NParam~\const \by 2,
        \TParam~\any \by \kw{int})
    }
\end{prooftree}
\wss
\begin{prooftree}
    \hypo{
        \kw{int} = \TParam[\eta_2]
    }
    \infer1{
        \kw{int} = \elementtype(\Array)[\eta_2]
    }
\end{prooftree}
\wss
\begin{prooftree}
    \infer0[T-Int-Literal]{
        \emptyset \vdash 1: \kw{int}, 2: \kw{int}
    }
\end{prooftree}
\wss
\begin{prooftree}
    \infer0[V]{
        \emptyset \vdash \kw{int} \imp \kw{int}
    }
\end{prooftree}
\wss
\begin{prooftree}
    \hypo{
        \begin{matrix}
            \emptyset \vdash \Array[2, \kw{int}] \ok  \\
            \ov{\Phi} = \typeparams(\Array)           \\
            \eta_2 = (\NParam \by 2,
            \TParam \by \kw{int})                     \\
            \kw{int} = \elementtype(\Array)[\eta_2]   \\
            \emptyset \vdash 1: \kw{int}, 2: \kw{int} \\
            \emptyset \vdash \kw{int} \imp \kw{int}
        \end{matrix}
    }
    \infer1[T-Array-Literal]{
        \emptyset \vdash \Array[2, \kw{int}]\br{1, 2} : \Array[2, \kw{int}]
    }
\end{prooftree}
\wss
\begin{prooftree}
    \hypo{
        (\First() \kw{int}) \in \methods_{\ov{\Phi}}(\Array[2, \kw{int}])
    }
    \hypo{
        \emptyset \vdash \Array[2, \kw{int}]\br{1, 2} : \Array[2, \kw{int}]
    }
    \infer2[T-Call]{
        \emptyset \vdash e : \kw{int}
    }
\end{prooftree}
\wss

\begin{prooftree}
    \infer0{
        \distinct(\tdecls(\ov{D}))
    }
    \infer0{
        \distinct(\mdecls(\ov{D}))
    }
    \hypo{
        D_0 \ok
    }
    \hypo{
        D_1 \ok
    }
    \hypo{
        D_2 \ok
    }
    \infer3{
        \ov{D \ok}
    }
    \hypo{
        \emptyset \vdash e : \kw{int}
    }
    \infer4[T-Prog]{ \package~\main;~\ov{D}~\func~\main()~\br{\un=e} \ok }
\end{prooftree}

\end{document}
