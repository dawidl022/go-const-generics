\begin{figure}
    \begin{mathpar}
        \inferrule
        {(\type~t_A~ [n]t) \in \ov{D}}
        {t = \elementtype(t_A)}

        \inferrule
        {(\type~t_A~ [n]t) \in \ov{D}}
        {n = \len(t_A)}

        \inferrule
        {~}
        {\methods(\kw{int}) = \{\}}

        \inferrule
        {~}
        {\methods(n) = \{\}}

        \gray{
            \inferrule
            {}
            {\methods(\black{t_V}) = \{
                mM \mid
                (\func~(x~\black{t_V})~mM~\br{\return~e}) \in \ov{D}
                \}\\
                \black{\cup~\{
                    m(x_1~\kw{int},~x_2~t) ~t_V~ \mid
                    (\func~(x~t_V) ~m(x_1~\kw{int},~x_2~t) ~t_V~
                    \br{ x[x_1] = x_2;~\return~x }) \in \ov{D}
                    \}}}
        }

        \gray{
            \inferrule
            {\type~t_I~\interface\br{\ov{S}} \in \ov{D}}
            {\methods(t_I) = \ov{S}}

            \inferrule
            {(\type~t_S~\struct\br{\ov{f~t}}) \in \ov{D}}
            {\fields(t_S) = \ov{f~t}}

            \inferrule
            {\text{$mM_1, mM_2 \in \ov{S}$ implies $M_1 = M_2$}}
            {\unique(\ov{S})}
        }

        \gray{
            \inferrule
            {}
            {\tdecls(\ov{D}) = \lst{\black{t_D} \mid (\type~\black{t_D}~T) \in \ov{D}}}

            \inferrule
            {}
            {\mdecls(\ov{D}) = \lst{\black{t_V}.m \mid
                    (\func~(x~\black{t_V})~mM~\br{\return~e}) \in \ov{D}}}
        }
    \end{mathpar}
    \caption{FG auxiliary functions for typing with arrays}
\end{figure}
