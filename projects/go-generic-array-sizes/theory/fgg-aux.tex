\begin{figure}
    \begin{mathpar}
        \gray{
        \inferrule
        {(\type~t_A\black{[\ov{\Phi}]}~ [\black{\tau_n}]\black{\tau}) \in \ov{D}}
        {\black{\tau} = \elementtype(t_A)}
        }

        \inferrule
        {
        \tau_A = t_A[\ov{\tau}] \\
        (\ov{\alpha~\gamma}) = \ov{\Phi} \\
        (\type~t_A[\ov{\Phi}]~ [\alpha_i]\tau) \in \ov{D}
        }
        {\tau_i = \len(\tau_A)}


        \gray{
        \inferrule
        {
        \black{\tau_A = t_A[\ov{\tau}]} \\
        (\type~t_A\black{[\ov{\Phi}]}~ [n]\black{\tau}) \in \ov{D}
        }
        {n = \len(\black{\tau}_A)}
        }


        \inferrule
        {(\type~t[\ov{\Phi}]~T) \in \ov{D}}
        {\ov{\Phi} = \typeparams(t)}

        \inferrule
        {\Delta \vdash \tau \imp \const}
        {\isconst_\Delta(\tau)}

        \inferrule
        {
            (\ov{\alpha~\gamma}) = \ov{\Phi} \\
            \eta = (\ov{\Phi \by \tau}) \\
            \Delta \vdash (\ov{\alpha \imp \gamma})\llbracket\eta\rrbracket \\
            \ov{\isconst_\Delta(\alpha) = \isconst_\Delta(\gamma)}\llbracket\eta\rrbracket
        }
        {(\ov{\Phi \by_\Delta \tau}) = \eta}

        \axiomrule{
            \notref_\alpha(\ov{t_r},~n)
        }

        \axiomrule{
            \notref_\alpha(\ov{t_r},~\kw{const})
        }

        \axiomrule{
            \notref_\alpha(\ov{t_r},~\alpha)
        }

        \inferrule
        {
            \ov{\notref_\alpha(\ov{t_r},~\tau)}
            \\
            \ov{t_r \neq t}
            \\
            (\ov{\alpha~\gamma}) = \typeparams(t)
            \\
            \ov{
                \notref_\alpha(\ov{t_r}, t, \gamma)
            }
        }
        {
            \notref_\alpha(\ov{t_r},~t[\ov{\tau}])
        }

        \inferrule
        {~}
        {
            \notref(\ov{t_r}, \alpha)
        }

        \gray{
            \inferrule
            {~}
            {
                \notref(\ov{t_r}, \kw{int})
            }

            \inferrule
            {~}
            {
                \notref(\ov{t_r},~\interface~\br{\ov{S}})
            }
        }
        \\
        \gray{
            \inferrule
            {
                \notref(\ov{t_r}, \black{\tau})
            }
            {
                \notref(\ov{t_r},~[\black{\tau_n}]\black{\tau})
            }

            \inferrule
            {
                \ov{\notref(\ov{t_r}, \black{\tau})}
            }
            {
                \notref(\ov{t_r},~\struct \br{\ov{f~\black{\tau}}})
            }
        }

        \gray{
            \inferrule
            {
                (\type~t_D\black{[\ov{\Phi}]}~T) \in \ov{D}
                \\
                \ov{t_r \neq t_D} \\
                \\
                \notref(\ov{t_r}, t_D, T)
            }
            {
                \notref(\ov{t_r}, t_D\black{[\ov{\tau}]})
            }

        }

        \gray{
            \inferrule
            {~}
            {\methods_\black{\Delta}(\kw{int}) = \{\}}
        }

        \gray{
            \inferrule
            {~}
            {\methods_\black{\Delta}(n) = \{\}}
        }

        \gray{
            % negative spacing to more ovenly overflow margins on both sides
            \mkern-24mu
            \inferrule
            {
                \black{ \eta = (\ov{\Phi \by \tau}) }
                \\
                \black{ \ov{\Phi} = \typeparams(t_V) }
            }
            {
                \methods_\black{\Delta}(t_V\black{[\ov{\tau}]}) =
                \{(mM)\black{\llbracket\eta\rrbracket}
                \mid (\func~(x~t_V\black{[\ov{\alpha}]})~mM~\br{\return~e}) \in \ov{D}
                \}
                \black{~\cup}
                \\
                \{
                m(x_1~\kw{int},~x_2~\black{\tau\llbracket\eta\rrbracket})~t_V\black{[\ov{\tau}]} \mid
                (\func~(x~t_V\black{[\ov{\alpha}]}) ~m(x_1~\kw{int},~x_2~\black{\tau}) ~t_V\black{[\ov{\alpha}]}~
                \br{ x[x_1] = x_2;~\return~x }) \in \ov{D}
                \}
            }
        }

        \gray{
            \inferrule
            {
                \type~t_I\black{[\ov{\Phi}]}~\interface~\br{\ov{S}} \in \ov{D} \\
                \black{ \eta = (\ov{\Phi \by \tau})}}
            {
                \methods_\black{\Delta}(t_I\black{[\ov{\tau}]}) =
                \ov{S}\black{\llbracket\eta\rrbracket}
            }
        }

        \inferrule
        {(\alpha : \black{\gamma}) \in \Delta}
        {\methods_\Delta(\alpha) = \methods_\Delta(\gamma)}

        \gray{
            \inferrule
            {\distinct(\ov{m})}
            {\unique(\ov{mM})}

            \inferrule
            {a_i \neq a_j~\forall a_i, a_j \in \ov{a},~i \neq j}
            {\distinct(\ov{a})}
        }

        \gray{
            \inferrule
            {}
            {\tdecls(\ov{D}) = \lst{t_D \mid (\type~t_D\black{[\ov{\Phi}]}~T) \in \ov{D}}}
        }

        \gray{
            \inferrule
            {}
            {\mdecls(\ov{D}) = \lst{t_V.m \mid
                    (\func~(x~t_V\black{[\ov{\alpha}]})~mM~\br{\return~e}) \in \ov{D}}}
        }
    \end{mathpar}
    \caption{FGG auxiliary functions for typing with arrays}
\end{figure}
