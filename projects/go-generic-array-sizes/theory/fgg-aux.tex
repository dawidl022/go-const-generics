\documentclass[acmsmall,screen]{acmart}
\usepackage{mathpartir}

\begin{document}

\include{macros}

$\Delta$ is defined as a typing environment mapping type parameters $\alpha$
to their bounds $\gamma$. Type parameter constraint sequences $\ov{\Phi}$ may
implicitly coerce to type environments.

\begin{figure}
    \begin{mathpar}
        \inferrule
        {(\type~t_A[\ov{\Phi}]~ [\tau_n]\tau) \in \ov{D}}
        {\tau = \elementtype(t_A)}

        \inferrule
        {
        \tau_A = t_A[\ov{\tau}] \\
        (\ov{\alpha~\gamma}) = \ov{\Phi} \\
        (\type~t_A[\ov{\Phi}]~ [\alpha_i]\tau) \in \ov{D}
        }
        {\tau_i = \len(\tau_A)}


        \inferrule
        {
        \tau_A = t_A[\ov{\tau}] \\
        (\type~t_A[\ov{\Phi}]~ [n]\tau) \in \ov{D}
        }
        {n = \len(\tau_A)}


        \inferrule
        {(\type~t[\ov{\Phi}]~T) \in \ov{D}}
        {\ov{\Phi} = \typeparams(t)}

        \inferrule
        {
            (\ov{\alpha~\gamma}) = \ov{\Phi} \\
            \gray{\eta = (\ov{\alpha \by \tau})}
        }
        {(\ov{\Phi \by \tau}) = \eta}

        \inferrule
        {\Delta \vdash \tau \imp \const}
        {\isconst_\Delta(\tau)}

        \inferrule
        {
            (\ov{\alpha~\gamma}) = \ov{\Phi} \\
            \eta = (\ov{\Phi \by \tau}) \\
            \Delta \vdash (\ov{\alpha \imp \gamma})[\eta] \\
            \ov{\isconst_\Delta(\alpha) = \isconst_\Delta(\gamma)}[\eta]
        }
        {(\ov{\Phi \by_\Delta \tau}) = \eta}

        \\
        \inferrule
        {~}
        {\methods_\Delta(\kw{int}) = \{\}}

        \inferrule
        {~}
        {\methods_\Delta(\const) = \{\}}

        \inferrule
        {~}
        {\methods_\Delta(n) = \{\}}

        \gray{
        \inferrule
        {}
        {
        \methods_\Delta(\black{t_V[\ov{\tau}]}) =
        \{(mM)[\eta]
        \mid (\func~(x~\black{t_V[\ov{\alpha}]})~mM~\br{\return~e}) \in \ov{D}
        \comma\\
        \eta = \black{
            (\ov{\Phi \by_\Delta \tau})
            \comma
            (\type~t_V[\ov{\Phi}]) \in \ov{D}
        }
        \}
        \\
        \black{\cup~\{
        m(x_1~\kw{int},~x_2~\tau[\eta]) \mid
        (\func~(x~t_V[\ov{\alpha}]) ~m(x_1~\kw{int},~x_2~\tau[\eta]) ~t_V~
        \br{ x[x_1] = x_2;~\return~x }) \in \ov{D}
        \comma
        }
        \\
        \black{
            \eta = (\black{\ov{\Phi \by_\Delta \tau}})
            \comma
            (\type~t_V[\ov{\Phi}]) \in \ov{D}
            \}}}
        }

        \gray{
            \inferrule
            {\type~t_I\black{[\ov{\Phi}]}~\interface~\br{\ov{S}} \in \ov{D} \\
                \eta = (\black{\ov{\Phi \by \tau}})}
            {\methods_\Delta(t_I\black{[\ov{\tau}]}) = \ov{S}[\eta]}

            \inferrule
            {(\alpha : \black{\gamma}) \in \Delta}
            {\methods_\Delta(\alpha) = \methods_\Delta(\black{\gamma})}
        }

        \gray{
            \inferrule
            {
                (\type~t_S\black{[\ov{\Phi}]}~\struct~\br{\ov{f~\tau}}) \in \ov{D} \\
                \eta = (\black{\ov{\Phi \by \sigma}})
            }
            {\fields(t_S\black{[\ov{\sigma}]}) = (\ov{f~\tau})[\eta]}

            \inferrule
            {\text{$mM_1, mM_2 \in \ov{S}$ implies $M_1 = M_2$}}
            {\unique(\ov{S})}
        }

        \gray{
        \inferrule
        {}
        {\tdecls(\ov{D}) = \lst{\black{t_D} \mid (\type~\black{t_D[\ov{\Phi}]}~T) \in \ov{D}}}

        \inferrule
        {}
        {\mdecls(\ov{D}) = \lst{\black{t_V}.m \mid
        (\func~(x~\black{t_V[\ov{\Phi}]})~mM~\br{\return~e}) \in \ov{D}}}
        }
    \end{mathpar}
    \caption{FGG auxiliary functions for array typing}
\end{figure}

\end{document}
