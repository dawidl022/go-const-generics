$\Delta$ is an environment mapping numerical type parameters $\alpha_n$ (i.e.
those bound by \kw{const}) to integer literals $n$.

% Formal rules describe process in two distinct stages, whereas implementation
% does both in a single stage.

\begin{figure}
    Type-instance sets \hfill \fbox{$\omega, \Omega$}
    \begin{mathpar}
        \omega, \Omega
        \text{ range over sets containing elements of the form }
        t[\ov{n}]
    \end{mathpar}

    Expressions and programs \hfill \fbox{$ \Delta \vdash e
            \yields \omega$} \quad \fbox{$P \yields \Omega$}

    \begin{mathpar}
        \inferrule[I-int-literal]{~}
        {\Delta \vdash n \yields \emptyset}

        \inferrule[I-var]
        {
            ~
        }
        {
            \Delta \vdash x \yields \emptyset
        }

        \inferrule[I-literal]
        {
        \Delta \vdash t_V[\ov{\tau}] \yields \omega_\tau
        \\
        \Delta \vdash \ov{e \yields \omega}
        }
        {
        \Delta \vdash  t_V[\ov{\tau}]\br{\ov{e}}\yields
        \ov{\omega_\tau}~
        \cup~\ov{\omega}
        }

        \inferrule[I-field]
        {
            \Delta \vdash e \yields \omega
        }
        {
            \Delta \vdash e.f_i \yields \omega
        }

        \inferrule[I-index]
        {
            \Delta \vdash e \yields \omega
            \\
            \Delta \vdash e' \yields \omega'
        }
        {
            \Delta \vdash e[e'] \yields \omega~\cup~\omega'
        }

        \inferrule[I-call]
        {
            \Delta \vdash e \yields \omega\\
            \Delta \vdash \ov{e \yields \omega}
        }
        {
            \Delta \vdash e.m(\ov{e}) \yields
            \omega~\cup~\ov{\omega}
        }

        \inferrule[I-prog]
        {
            \emptyset \vdash e \yields \omega \\
            \Omega = \lim_{n \rightarrow \infty}  G^{n}(\omega)
        }
        {
            \package~\main;~\ov{D}~\func~\main()~\br{\un=e} \yields \Omega
        }
    \end{mathpar}

    Method specifications and type literals
    \hfill \fbox{$\Delta \vdash S \yields \omega $}
    \quad \fbox{$\Delta \vdash T \yields \omega $}

    \begin{mathpar}
        \inferrule[I-specification]{
            \Delta \vdash \ov{\tau \yields \omega}
            \\
            \Delta \vdash \tau \yields \omega
        }{
            \Delta \vdash m(\ov{x~\tau})~\tau \yields \omega~\cup~\ov{\omega}
        }

        \inferrule[I-struct]{
            \Delta \vdash \ov{\tau \yields \omega}
        }{
            \Delta \vdash \struct~\br{\ov{f~\tau}} \yields \ov{\omega}
        }

        \inferrule[I-array]{
            \Delta \vdash \tau \yields \omega
        }{
            \Delta \vdash [\tau_n]\tau \yields \omega
        }

        \inferrule[I-interface]{
            \Delta \vdash \ov{S \yields \omega}
        }{
            \Delta \vdash \interface~\br{\ov{S}} \yields \ov{\omega}
        }
    \end{mathpar}

    Types \hfill \fbox{$\Delta \vdash \tau \yields \omega $}

    \begin{mathpar}
        \inferrule[I-int]{~}{
            \Delta \vdash \kw{int} \yields \emptyset
        }

        \inferrule[I-n]{~}{
            \Delta \vdash n \yields \emptyset
        }

        \inferrule[I-$\alpha$]{~}{
            \Delta \vdash \alpha \yields \emptyset
        }

        \inferrule[I-const]{~}{
            \Delta \vdash \kw{const} \yields \emptyset
        }

        \inferrule[I-named]{
            \ov{\tau \yields \omega_\tau}
        }{
            \Delta \vdash t[\ov{\tau}] \yields
            \set{\instance(t[\ov{\tau}]\llbracket\Delta\rrbracket)}
            \cup \ov{\omega_\tau}
        }
    \end{mathpar}

\end{figure}

\begin{figure}

    Auxiliary functions

    \begin{mathpar}
        \inferrule
        {
            \ov{n} = \ov{n : n \in \ov{\tau}}
        }
        {
            \instance(t[\ov{\tau}]) = t[\ov{n}]
        }

        \inferrule
        {
            \ov{\alpha_n} = \ov{\alpha: \alpha~\kw{const} \in \ov{\Phi}}
        }
        {
            (\ov{\Phi} \by \ov{n}) = (\ov{\alpha_n \by n})
        }
    \end{mathpar}

    \begin{mathpar}
        G(\omega) = \TExtensionD{\omega}{\Delta} \cup
        \MExtensionD{\omega}{\Delta} \cup \ASMExtensionD{\omega}{\Delta}

        \TExtensionD{\omega}{\Delta}   = \bigcup\left\{
        \ov{\omega'}\cup\omega''
        \;\middle|\;
        \begin{array}{c}
            t[\ov{n}] \in \omega
            \comma
            (\type~t[\ov{\Phi}]~T) \in \ov{D}
            \comma
            \ov{\Phi} = (\ov{\alpha~\gamma})
            \comma
            \\
            \ov{(\ov{\Phi} \by \ov{n}) \vdash \gamma \yields \omega' }
            \comma
            (\ov{\Phi} \by \ov{n}) \vdash T \yields \omega''
        \end{array}
        \right\}
        \\
        \MExtensionD{\omega}{\Delta}   = \bigcup\left\{
        \omega'\cup\omega''
        \;\middle|\;
        \begin{array}{c}
            t_V[\ov{n}] \in \omega
            \comma
            (\func~(x~t_V[\ov{\alpha}])~mM~\br{\return~e}) \in \ov{D}
            \comma
            \\
            \ov{\Phi} = \typeparams(t_V)
            \comma
            (\ov{\Phi} \by \ov{n}) \vdash mM \yields \omega'
            \comma
            (\ov{\Phi} \by \ov{n}) \vdash e \yields \omega''
        \end{array}
        \right\}
        \\
        \ASMExtensionD{\omega}{\Delta}  = \bigcup\left\{
        \omega'
        \;\middle|\;
        \begin{array}{c}
            t_V[\ov{n}] \in \omega
            \comma
            \ov{\Phi} = \typeparams(t_V)
            \comma
            (\ov{\Phi} \by \ov{n}) \vdash \tau \yields \omega'
            \comma
            \\
            (\func~(x~t_V[\ov{\alpha}]) ~m(x_1~\kw{int},~x_2~\tau) ~t_V[\ov{\alpha}]~
            \br{ x[x_1] = x_2;~\return~x }) \in \ov{D}
        \end{array}
        \right\}
    \end{mathpar}

    \caption{Type collection phase of FGGA to Go monormorphisation}
\end{figure}

\begin{figure}

    Auxiliary functions

    \begin{mathpar}
        \inferrule{
            \ov{\Phi} = (\ov{\alpha~\gamma})
            \\
            \ov{\alpha_c} = \ov{\alpha: (\alpha \in \ov{\alpha}) \wedge
                ((\alpha~\const) \notin \ov{\Phi})}
        }{
            \ov{\Phi} \by \ov{\alpha_c}
        }
        \\
        \calD(\Omega) = \calD_T(\Omega) \cup \calD_M(\Omega) \cup \calD_A(\Omega)
        \\
        \calD_T(\Omega) = \left\{
        \inferrule[]{
        t[\ov{n}] \in \Omega
        \\
        (\type~t[\ov{\Phi}]~T) \in \ov{D}
        \\
        (\ov{\Phi} \by \ov{n}) \vdash \ov{\Phi} \mapsto \ov{\Phi}^\dagger
        \\
        (\ov{\Phi} \by \ov{n}) \vdash T \mapsto T^\dagger
        }{
        \type~\an{t, \ov{n}}[\ov{\Phi}^\dagger]~T^\dagger
        }
        \right\}

        \calD_M(\Omega) = \left\{
        \inferrule[]{
        t_V[\ov{n}] \in \Omega
        \\
        (\func~(x~t_V[\ov{\alpha}])~mM~\br{\return~e}) \in \ov{D}
        \\
        \ov{\Phi} = \typeparams(t_V)
        \\
        \ov{\Phi} \by \ov{\alpha_c}
        \\
        (\ov{\Phi} \by \ov{n}) \vdash M \mapsto M^\dagger
        \\
        (\ov{\Phi} \by \ov{n}) \vdash e \mapsto e^\dagger
        }{
        \func (x~ \an{t_V, \ov{n}}[\ov{\alpha_c}])~mM^\dagger~\br{ \return~e^\dagger }
        }
        \right\}

        \calD_A(\Omega) = \left\{
        \inferrule[]{
        t_V[\ov{n}] \in \Omega
        \\
        (\func~(x~t_V[\ov{\alpha}]) ~m(x_1~\kw{int},~x_2~\tau) ~t_V[\ov{\alpha}]~
        \br{ x[x_1] = x_2;~\return~x }) \in \ov{D}
        \\
        \ov{\Phi} = \typeparams(t_V)
        \\
        \ov{\Phi} \by \ov{\alpha_c}
        \\
        (\ov{\Phi} \by \ov{n}) \vdash \tau \mapsto \tau^\dagger
        }{
        \func~(x~\an{t_V, \ov{n}}[\ov{\alpha_c}])~m(x_1~\kw{int}, x_2~\tau^\dagger)
        ~\an{t_V, \ov{n}}[\ov{\alpha_c}]~
        \br{ x[x_1] = x_2;~\return~x }
        }
        \right\}
    \end{mathpar}

    \caption{Translation phase of FGGA to Go monormorphisation}
\end{figure}
