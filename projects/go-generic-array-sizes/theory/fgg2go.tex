$\Delta$ is an environment mapping numerical type parameters $\alpha_n$ (i.e.
those bound by \kw{const}) to integer literals $n$.

% Formal rules describe process in two distinct stages, whereas implementation
% does both in a single stage.

\begin{figure}
    Type-instance sets \hfill \fbox{$\omega, \Omega$}
    \begin{mathpar}
        \omega, \Omega
        \text{ range over sets containing elements of the form }
        t[\ov{n}]
    \end{mathpar}

    Expressions and programs \hfill \fbox{$ \Delta \vdash e
            \yields \omega$} \quad \fbox{$P \yields \Omega$}

    \begin{mathpar}
        \inferrule[I-int-literal]{~}
        {\Delta \vdash n \yields \emptyset}

        \inferrule[I-var]
        {
            ~
        }
        {
            \Delta \vdash x \yields \emptyset
        }

        \inferrule[I-literal]
        {
        \Delta \vdash t_V[\ov{\tau}] \yields \omega_\tau
        \\
        \Delta \vdash \ov{e \yields \omega}
        }
        {
        \Delta \vdash  t_V[\ov{\tau}]\br{\ov{e}}\yields
        \ov{\omega_\tau}~
        \cup~\ov{\omega}
        }

        \inferrule[I-field]
        {
            \Delta \vdash e \yields \omega
        }
        {
            \Delta \vdash e.f_i \yields \omega
        }

        \inferrule[I-index]
        {
            \Delta \vdash e \yields \omega
            \\
            \Delta \vdash e' \yields \omega'
        }
        {
            \Delta \vdash e[e'] \yields \omega~\cup~\omega'
        }

        \inferrule[I-call]
        {
            \Delta \vdash e \yields \omega\\
            \Delta \vdash \ov{e \yields \omega}
        }
        {
            \Delta \vdash e.m(\ov{e}) \yields
            \omega~\cup~\ov{\omega}
        }

        \inferrule[I-prog]
        {
            \emptyset \vdash e \yields \omega \\
            \Omega = \lim_{n \rightarrow \infty}  G_{\emptyset}^{n}(\omega)
        }
        {
            \package~\main;~\ov{D}~\func~\main()~\br{\un=e} \yields \Omega
        }
    \end{mathpar}

    Method specifications \hfill \fbox{$\Delta \vdash S \yields \omega $}

    \begin{mathpar}
        \inferrule[I-specification]{
            \Delta \vdash \ov{\tau \yields \omega}
            \\
            \Delta \vdash \tau \yields \omega
        }{
            \Delta \vdash m(\ov{x~\tau})~\tau \yields \omega~\cup~\ov{\omega}
        }
    \end{mathpar}

    Types \hfill \fbox{$\Delta \vdash \tau \yields \omega $}

    \begin{mathpar}
        \inferrule[I-int]{~}{
            \Delta \vdash \kw{int} \yields \emptyset
        }

        \inferrule[I-n]{~}{
            \Delta \vdash n \yields \emptyset
        }

        \inferrule[I-$\alpha$]{~}{
            \Delta \vdash \alpha \yields \emptyset
        }

        \inferrule[I-const]{~}{
            \Delta \vdash \kw{const} \yields \emptyset
        }

        \inferrule[I-named]{
            \black{\ov{\tau \yields \omega_\tau}}
        }{
            \Delta \vdash t[\ov{\tau}] \yields
            \set{\instance(t[\ov{\tau}]\llbracket\Delta\rrbracket)}
            \cup \ov{\omega_\tau}
        }
    \end{mathpar}

\end{figure}

\begin{figure}

    Auxiliary functions

    \begin{mathpar}
        \inferrule
        {
            \ov{n} = \ov{n : n \in \ov{\tau}}
        }
        {
            \instance(t[\ov{\tau}]) = t[\ov{n}]
        }

        \inferrule
        {
            \ov{\alpha_n} = \ov{\alpha: \alpha~\kw{const} \in \ov{\Phi}}
        }
        {
            (\ov{\Phi} \by \ov{n}) = (\ov{\alpha_n \by n})
        }
    \end{mathpar}

    \begin{align*}
        % TODO collapse 3 aux into one and use regular rules for type literals
        \FExtensionD{\omega}{\Delta} & = \bigcup\left\{\Strut
        \ov{\omega'}
        \;\middle|\;
        t_S[\ov{n}] \in \omega \comma
        (\type~t_S[\ov{\Phi}]~\struct~\br{\ov{f~\black{\tau}}}) \in \ov{D}
        \comma
        \ov{(\ov{\Phi} \by \ov{n}) \vdash \tau \yields \omega'}
        \right\}
        \\
        \EExtensionD{\omega}{\Delta} & = \bigcup\left\{
        \omega'
        \;\middle|\;
        t_A[\ov{n}] \in \omega
        \comma
        (\type~t_A[\ov{\Phi}]~[\tau_n]\tau) \in \ov{D}
        \comma
        (\ov{\Phi} \by \ov{n}) \vdash \tau \yields \omega'
        \right\}
        \\
        \SExtensionD{\omega}{\Delta} & = \bigcup\left\{
        \ov{\omega'}
        \;\middle|\;
        t_I[\ov{n}] \in \omega
        \comma
        (\type~t_I[\ov{\Phi}]~\interface~\br{\ov{S}}) \in \ov{D}
        \comma
        \ov{(\ov{\Phi} \by \ov{n}) \vdash S \yields \omega' }
        \right\}
        \\
        \PExtensionD{\omega}{\Delta} & =  \bigcup\left\{
        \ov{\omega'}
        \;\middle|\;
        t[\ov{n}] \in \omega
        \comma
        (\type~t[\ov{\Phi}]~T) \in \ov{D}
        \comma
        \ov{\Phi} = (\ov{\alpha~\gamma})
        \comma
        \ov{(\ov{\Phi} \by \ov{n}) \vdash \gamma \yields \omega' }
        \right\}
    \end{align*}

\end{figure}
