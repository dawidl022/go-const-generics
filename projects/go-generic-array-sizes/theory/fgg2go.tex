$\Delta$ is an environment mapping numerical type parameters $\alpha_n$ (i.e.
those bound by \kw{const}) to integer literals $n$.

% Formal rules describe process in two distinct stages, whereas implementation
% does both in a single stage.

\begin{figure}
    Type-instance sets \hfill \fbox{$\omega, \Omega$}
    \begin{mathpar}
        \omega, \Omega
        \text{ range over sets containing elements of the form }
        t[\ov{n}]
    \end{mathpar}

    Expressions and programs \hfill \fbox{$ \Delta \vdash e
            \yields \omega$} \quad \fbox{$P \yields \Omega$}

    \begin{mathpar}
        \inferrule[I-int-literal]{~}
        {\Delta \vdash n \yields \emptyset}

        \inferrule[I-var]
        {
            ~
        }
        {
            \Delta \vdash x \yields \emptyset
        }

        \inferrule[I-literal]
        {
        \Delta \vdash t_V[\ov{\tau}] \yields \omega_\tau
        \\
        \Delta \vdash \ov{e \yields \omega}
        }
        {
        \Delta \vdash  t_V[\ov{\tau}]\br{\ov{e}}\yields
        \ov{\omega_\tau}~
        \cup~\ov{\omega}
        }

        \inferrule[I-field]
        {
            \Delta \vdash e \yields \omega
        }
        {
            \Delta \vdash e.f_i \yields \omega
        }

        \inferrule[I-index]
        {
            \Delta \vdash e \yields \omega
            \\
            \Delta \vdash e' \yields \omega'
        }
        {
            \Delta \vdash e[e'] \yields \omega~\cup~\omega'
        }

        \inferrule[I-call]
        {
            \Delta \vdash e \yields \omega\\
            \Delta \vdash \ov{e \yields \omega}
        }
        {
            \Delta \vdash e.m(\ov{e}) \yields
            \omega~\cup~\ov{\omega}
        }

        \inferrule[I-prog]
        {
            \emptyset \vdash e \yields \omega \\
            \Omega = \lim_{n \rightarrow \infty}  G^{n}(\omega)
        }
        {
            \package~\main;~\ov{D}~\func~\main()~\br{\un=e} \yields \Omega
        }
    \end{mathpar}

    Method specifications and type literals
    \hfill \fbox{$\Delta \vdash S \yields \omega $}
    \quad \fbox{$\Delta \vdash T \yields \omega $}

    \begin{mathpar}
        \inferrule[I-specification]{
            \Delta \vdash \ov{\tau \yields \omega}
            \\
            \Delta \vdash \tau \yields \omega
        }{
            \Delta \vdash m(\ov{x~\tau})~\tau \yields \omega~\cup~\ov{\omega}
        }

        \inferrule[I-struct]{
            \Delta \vdash \ov{\tau \yields \omega}
        }{
            \Delta \vdash \struct~\br{\ov{f~\tau}} \yields \ov{\omega}
        }

        \inferrule[I-array]{
            \Delta \vdash \tau \yields \omega
        }{
            \Delta \vdash [\tau_n]\tau \yields \omega
        }

        \inferrule[I-interface]{
            \Delta \vdash \ov{S \yields \omega}
        }{
            \Delta \vdash \interface~\br{\ov{S}} \yields \ov{\omega}
        }
    \end{mathpar}

    Types \hfill \fbox{$\Delta \vdash \tau \yields \omega $}

    \begin{mathpar}
        \inferrule[I-int]{~}{
            \Delta \vdash \kw{int} \yields \emptyset
        }

        \inferrule[I-n]{~}{
            \Delta \vdash n \yields \emptyset
        }

        \inferrule[I-$\alpha$]{~}{
            \Delta \vdash \alpha \yields \emptyset
        }

        \inferrule[I-const]{~}{
            \Delta \vdash \kw{const} \yields \emptyset
        }

        \inferrule[I-named]{
            \black{\ov{\tau \yields \omega_\tau}}
        }{
            \Delta \vdash t[\ov{\tau}] \yields
            \set{\instance(t[\ov{\tau}]\llbracket\Delta\rrbracket)}
            \cup \ov{\omega_\tau}
        }
    \end{mathpar}

\end{figure}

\begin{figure}

    Auxiliary functions

    \begin{mathpar}
        \inferrule
        {
            \ov{n} = \ov{n : n \in \ov{\tau}}
        }
        {
            \instance(t[\ov{\tau}]) = t[\ov{n}]
        }

        \inferrule
        {
            \ov{\alpha_n} = \ov{\alpha: \alpha~\kw{const} \in \ov{\Phi}}
        }
        {
            (\ov{\Phi} \by \ov{n}) = (\ov{\alpha_n \by n})
        }
    \end{mathpar}

    \begin{mathpar}
        G(\omega) = \TExtensionD{\omega}{\Delta} \cup
        \MExtensionD{\omega}{\Delta} \cup \ASMExtensionD{\omega}{\Delta}

        \TExtensionD{\omega}{\Delta}   = \bigcup\left\{
        \ov{\omega'}\cup\omega''
        \;\middle|\;
        \begin{array}{c}
            t[\ov{n}] \in \omega
            \comma
            (\type~t[\ov{\Phi}]~T) \in \ov{D}
            \comma
            \ov{\Phi} = (\ov{\alpha~\gamma})
            \comma
            \\
            \ov{(\ov{\Phi} \by \ov{n}) \vdash \gamma \yields \omega' }
            \comma
            (\ov{\Phi} \by \ov{n}) \vdash T \yields \omega''
        \end{array}
        \right\}
        \\
        \MExtensionD{\omega}{\Delta}   = \bigcup\left\{
        \omega'\cup\omega''
        \;\middle|\;
        \begin{array}{c}
            t_V[\ov{n}] \in \omega
            \comma
            (\func~(x~t_V\black{[\ov{\alpha}]})~mM~\br{\return~e}) \in \ov{D}
            \comma
            \\
            \ov{\Phi} = \typeparams(t_V)
            \comma
            (\ov{\Phi} \by \ov{n}) \vdash mM \yields \omega'
            \comma
            (\ov{\Phi} \by \ov{n}) \vdash e \yields \omega''
        \end{array}
        \right\}
        \\
        \ASMExtensionD{\omega}{\Delta}  = \bigcup\left\{
        \omega'
        \;\middle|\;
        \begin{array}{c}
            t_V[\ov{n}] \in \omega
            \comma
            \ov{\Phi} = \typeparams(t_V)
            \comma
            (\ov{\Phi} \by \ov{n}) \vdash \tau \yields \omega'
            \comma
            \\
            (\func~(x~t_V\black{[\ov{\alpha}]}) ~m(x_1~\kw{int},~x_2~\black{\tau}) ~t_V\black{[\ov{\alpha}]}~
            \br{ x[x_1] = x_2;~\return~x }) \in \ov{D}
        \end{array}
        \right\}
    \end{mathpar}
\end{figure}
